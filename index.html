<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>FSP Audio ‚Äî G√ºncel</title>

  <meta name="description" content="FSP Audio ‚Äî G√ºncel kayƒ±t listesi ve oynatƒ±cƒ±." />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="FSP Audio ‚Äî G√ºncel" />
  <meta property="og:description" content="G√ºncel FSP kayƒ±tlarƒ±..." />
  <meta property="og:url" content="https://protokolfsp.github.io/fsp-audio/" />
  <meta property="og:image" content="https://protokolfsp.github.io/fsp-audio/og-home.png" />
  <meta property="og:image:width" content="1200" />
  <meta property="og:image:height" content="630" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:image" content="https://protokolfsp.github.io/fsp-audio/og-home.png" />

  <script async src="https://www.googletagmanager.com/gtag/js?id=G-TNRQ49C157"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    const __isDebug = new URLSearchParams(location.search).has('debug');
    gtag('config', 'G-TNRQ49C157', { debug_mode: __isDebug, send_page_view: true });
  </script>

  <link rel="stylesheet" href="https://cdn.plyr.io/3.7.8/plyr.css" />

  <style>
    :root{
      --capLines: 6;
      --border:#e9e9e9;
      --muted:#6b6b6b;
      --bg:#ffffff;
      --hover:#f7f7f7;

      --active:#cfe9ff;
      --activeGlow: 0 0 0 2px rgba(43,124,255,.34) inset, 0 12px 26px rgba(43,124,255,.14);

      --blue:#2b7cff;
      --blueGlow: 0 0 0 4px rgba(43,124,255,.24), 0 10px 22px rgba(43,124,255,.10);

      --green:#16a34a;
      --greenGlow: 0 0 0 4px rgba(22,163,74,.22), 0 10px 22px rgba(22,163,74,.10);

      --orange:#f59e0b;
    }

    html, body{
      height: 100%;
      overscroll-behavior-y: none;
      background: var(--bg);
      -webkit-text-size-adjust: 100%;
      text-size-adjust: 100%;
    }

    body{
      margin: 0;
      overflow: visible;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color:#111;
      line-height: 1.10;
    }

    #scrollArea{
      height: 100%;
      overflow: auto;
      -webkit-overflow-scrolling: touch;
      overscroll-behavior-y: contain;
      padding: 18px;
      max-width: 980px;
      margin: 0 auto;
    }

    #appScale{
      transform-origin: top left;
      will-change: transform;
    }

    .pageTitle{
      font-size: 1.6rem;
      font-weight: 700;
      color: #0b5fff;
      background: #f1f5ff;
      padding: 12px 16px;
      border-radius: 14px;
      margin-bottom: 14px;
      display: none;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
    }

    #sidebarOpenBtn{
      width: 44px;
      height: 40px;
      border-radius: 14px;
      border: 1px solid #d8d8d8;
      background: white;
      cursor: pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      user-select:none;
      flex: 0 0 auto;
    }
    #sidebarOpenBtn:hover{ background: var(--hover); }
    #sidebarOpenBtn svg{ width: 18px; height: 18px; }

    .navRow{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap: wrap;
      margin: 0 0 12px 0;
    }
    .navLink{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding: 8px 14px;
      border-radius: 999px;
      border: 1px solid #d8d8d8;
      background: white;
      color:#111;
      text-decoration:none;
      font-size: .95rem;
      line-height: 1;
      user-select:none;
      transition: background .15s ease, box-shadow .15s ease, border-color .15s ease;
    }
    .navLink:hover{ background: var(--hover); }
    .navLink.on{
      border-color:var(--blue);
      background: rgba(43,124,255,.10);
      box-shadow: 0 0 0 3px rgba(43,124,255,.16) inset;
    }

    .topbar{
      display:flex;
      gap:12px;
      align-items:center;
      margin-bottom: 8px;
      flex-wrap: wrap;
    }

    /* Sticky bar (CSS sticky where it works, JS docks it where it doesn't) */
    #stickyBar{
      position: sticky;
      top: 0;
      z-index: 1200;
      background: var(--bg);
      padding: 10px 0;
      border-radius: 16px;
      box-shadow:
        0 1px 0 rgba(0,0,0,.06),
        0 10px 18px rgba(0,0,0,.05);
    }
    #stickyBar.docked{
      position: fixed;
      z-index: 1200;
      padding: 10px 0;
      border-radius: 16px;
      box-shadow:
        0 1px 0 rgba(0,0,0,.06),
        0 14px 28px rgba(0,0,0,.10);
    }
    #stickyBarPh{ height: 0; }

    #search{
      flex: 1 1 520px;
      min-width: 220px;
      height: 46px;
      padding: 0 14px;
      border: 1px solid #d8d8d8;
      border-radius: 16px;
      font-size: 1.05rem;
      outline: none;
    }

    #resetBtn{
      height: 46px;
      padding: 0 16px;
      border: 1px solid #d8d8d8;
      border-radius: 16px;
      background: white;
      cursor: pointer;
      font-size: 1rem;
      flex: 0 0 auto;
    }
    #resetBtn:hover{ background: var(--hover); }

    .zoomWrap{
      display:flex;
      align-items:center;
      gap: 24px;
      margin-left: 14px;
      padding: 6px;
      border: 1px solid #d8d8d8;
      border-radius: 14px;
      background: white;
      user-select:none;
      flex: 0 0 auto;
    }
    .zoomBtn{
      height: 36px;
      width: 48px;
      border-radius: 12px;
      border: 1px solid #d8d8d8;
      background: white;
      cursor: pointer;
      line-height: 1;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 0;
      -webkit-tap-highlight-color: transparent;
      transition: opacity .15s ease, box-shadow .15s ease, border-color .15s ease, background .15s ease, filter .15s ease;
    }
    .zoomBtn:hover{ background: var(--hover); }
    .zoomBtn:disabled{ opacity: .35; cursor: default; }

    .zoomBtn svg{
      width: 20px;
      height: 20px;
      stroke: currentColor;
      fill: none;
      stroke-width: 2;
      stroke-linecap: round;
      stroke-linejoin: round;
      opacity: .95;
    }

    .zoomBtn.zoomOut,
    .zoomBtn.zoomIn{
      opacity: .55;
      filter: saturate(1.2);
      color: #111;
    }

    .zoomBtn.enabled.zoomOut{
      opacity: 1;
      background: rgba(255, 149, 0, .18);
      border-color: rgba(255, 149, 0, .70);
      box-shadow: 0 0 0 3px rgba(255, 149, 0, .16) inset, 0 8px 18px rgba(255, 149, 0, .12);
      filter: saturate(1.7);
      color: #b45309;
    }
    .zoomBtn.enabled.zoomIn{
      opacity: 1;
      background: rgba(34, 197, 94, .18);
      border-color: rgba(34, 197, 94, .70);
      box-shadow: 0 0 0 3px rgba(34, 197, 94, .16) inset, 0 8px 18px rgba(34, 197, 94, .12);
      filter: saturate(1.7);
      color: #15803d;
    }

    #meta{
      color: var(--muted);
      font-size: .95rem;
      margin: 6px 0 12px 2px;
      line-height: 1.05;
    }

    /* 7 column layout:
       1) title
       2) duration
       3) play count
       4) fav
       5) download
       6) download count
       7) transcript (txt)
    */
    .headerRow, .itemRow{
      display: grid;
      grid-template-columns: minmax(0, 1fr) 8ch 54px 36px 36px 54px 36px;
      align-items: center;
      column-gap: 8px;
    }

    .headerRow{
      padding: 6px 8px;
      border-top: 1px solid var(--border);
      border-bottom: 1px solid var(--border);
      color: var(--muted);
      font-size: .92rem;
      line-height: 1.05;
    }

    .titleHead, .durHead{
      display:flex;
      align-items:center;
      gap:8px;
      user-select:none;
      width: 100%;
    }
    .titleHead{ justify-content:flex-start; }
    .durHead{ justify-content:flex-end; }

    .headIconCell{
      display:flex;
      align-items:center;
      justify-content:center;
      user-select:none;
    }

    .txtHead{
      font-size: .85rem;
      color: var(--muted);
      user-select:none;
      line-height: 1;
    }

    .sortBtn{
      width: 28px;
      height: 28px;
      border-radius: 999px;
      border: 1px solid #d8d8d8;
      background: white;
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      color:#111;
      flex: 0 0 auto;
      position: relative;
    }
    .sortBtn:hover{ background: var(--hover); }
    .sortBtn.on{
      border-color:var(--blue);
      box-shadow: 0 0 0 3px rgba(43,124,255,.12) inset;
    }

    .sortBtn svg{
      width: 20px;
      height: 20px;
      display: block;
      flex: 0 0 auto;
    }
    .sortBtn .mainIcon{
      width: 20px;
      height: 20px;
    }
    .sortBtn .dirIcon{
      position: absolute;
      right: 4px;
      bottom: 2px;
      width: 12px;
      height: 12px;
      opacity: .95;
    }

    .iconOrange{ fill: var(--orange); }
    .iconBlue{ fill: var(--blue); }

    #list{
      border-bottom: 1px solid var(--border);
    }

    .itemRow{
      padding: 4px 8px;
      border-bottom: 1px solid #ececec;
      cursor: pointer;
      background: #f7f7f7;
    }
    #list .itemRow:nth-child(even){
      background: #eeeeee;
    }
    .itemRow:hover{ background: var(--hover); }

    .itemRow.active{
      background: var(--active) !important;
      box-shadow: var(--activeGlow);
      position: relative;
    }
    .itemRow.active:hover{ background: var(--active) !important; }
    .itemRow.active::before{
      content:"";
      position:absolute;
      left:0;
      top:0;
      bottom:0;
      width:4px;
      background: var(--blue);
      border-radius: 4px;
    }

    .title{
      font-size: 1.02rem;
      font-weight: 500;
      line-height: 1.02;
      min-width: 0;
    }

    .dur{
      text-align:right;
      color: var(--muted);
      font-variant-numeric: tabular-nums;
      font-size: .95rem;
      user-select:none;
      white-space: nowrap;
      line-height: 1.00;
    }

    .countCell{
      text-align: right;
      color: #404040;
      font-variant-numeric: tabular-nums;
      font-size: .92rem;
      user-select:none;
      white-space: nowrap;
      line-height: 1.00;
      padding-right: 2px;
    }

    @media (max-width: 680px){
      #scrollArea{ padding: 14px; }
      .headerRow, .itemRow{ grid-template-columns: minmax(0, 1fr) 8ch 46px 34px 34px 46px 34px; }
      .title{
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      #search{ flex: 1 1 100%; }
      .zoomWrap{ margin-left: 0; }
    }

    .iconBtn{
      width: 30px;
      height: 30px;
      border-radius: 999px;
      border: 1px solid #d8d8d8;
      background: white;
      display:flex;
      align-items:center;
      justify-content:center;
      cursor: pointer;
      user-select:none;
      transition: box-shadow .15s ease, border-color .15s ease, background .15s ease, opacity .15s ease;
      justify-self: center;
      -webkit-tap-highlight-color: transparent;
    }
    .iconBtn:hover{ background: var(--hover); }
    .iconBtn:disabled{ opacity: .35; cursor: default; }
    .iconBtn:disabled:hover{ background: white; }

    .iconBtn.txtMissing{
      opacity: .22 !important;
      filter: grayscale(1);
      border-style: dashed;
    }

    .iconBtn.on{
      border-color: var(--blue);
      background: rgba(43,124,255,.10);
      box-shadow: var(--blueGlow);
    }
    .iconBtn svg{ width: 14px; height: 14px; opacity: .9; }

    /* TXT icon: blue tendency */
    .iconBtn[data-kind="txt"]:not(.txtMissing){
      border-color: rgba(43,124,255,.55);
      background: rgba(43,124,255,.08);
    }
    .iconBtn[data-kind="txt"]:not(.txtMissing):hover{ background: rgba(43,124,255,.14); }
    .iconBtn[data-kind="txt"] svg{ stroke: var(--blue); }


    .filterBtn{
      width: 30px;
      height: 30px;
      border-radius: 999px;
      border: 1px solid #d8d8d8;
      background: white;
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      color:#111;
    }
    .filterBtn:hover{ background: var(--hover); }
    .filterBtn.on{
      border-color:var(--blue);
      box-shadow: 0 0 0 3px rgba(43,124,255,.12) inset;
    }
    .filterBtn svg{ width:14px; height:14px; }

    #floatingPlayer{
      position: fixed;
      left: max(18px, env(safe-area-inset-left));
      bottom: max(18px, env(safe-area-inset-bottom));
      width: min(720px, calc(100vw - 36px));
      background: white;

      border: 1.5px solid #d6d6d6;
      border-right-color: #bdbdbd;
      border-bottom-color:#b3b3b3;
      border-radius: 18px;

      box-shadow:
        10px 34px 86px rgba(0,0,0,.20),
        4px 14px 30px rgba(0,0,0,.10),
        0px 2px 6px rgba(0,0,0,.06);

      overflow: visible;
      z-index: 9999;

      -webkit-transform: translateZ(0);
      transform: translateZ(0);
      transform-origin: top left;
      will-change: transform;
      transition: opacity .18s ease;
      touch-action: none;
    }

    /* Typing mode: do not block pointer events */
    #floatingPlayer.hiddenWhileTyping{ opacity: .35; }

    #fpHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 10px 12px;
      background: #fbfbfb;

      cursor: grab;
      user-select:none;
      gap: 10px;
      touch-action: none;
      line-height: 1.05;

      border-bottom: none;
      position: relative;

      box-shadow:
        inset 0 1px 0 rgba(255,255,255,.85),
        inset 0 -1px 0 rgba(0,0,0,.04);
    }

    #fpHeader::after{
      content:"";
      position:absolute;
      left:0; right:0; bottom:0;
      height: 2px;
      background: linear-gradient(
        to bottom,
        rgba(0,0,0,.18),
        rgba(255,255,255,.80)
      );
    }

    #fpTitle{
      font-weight: 650;
      font-size: 1rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      flex: 1 1 auto;
      min-width: 0;
      line-height: 1.12;
    }

    #fpHeaderRight{
      display:flex;
      align-items:center;
      gap: 8px;
      flex: 0 0 auto;
    }

    .miniBtn{
      width: 36px;
      height: 36px;
      border-radius: 12px;
      border: 1px solid #d8d8d8;
      background: white;
      cursor: pointer;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .miniBtn:hover{ background: var(--hover); }
    .miniBtn svg{ width:16px; height:16px; }

    .speedWrap{
      display:flex;
      align-items:center;
      gap: 6px;
      padding: 4px;
      border: 1px solid #d8d8d8;
      border-radius: 14px;
      background: white;
      user-select:none;
    }
    .speedCtlBtn{
      width: 36px;
      height: 36px;
      border-radius: 12px;
      border: 1px solid #d8d8d8;
      background: white;
      cursor: pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: 18px;
      line-height: 1;
    }
    .speedCtlBtn:hover{ background: var(--hover); }

    .speedValue{
      min-width: 56px;
      height: 36px;
      border-radius: 12px;
      border: 1px solid #d8d8d8;
      background: white;
      display:flex;
      align-items:center;
      justify-content:center;
      font-variant-numeric: tabular-nums;
      font-weight: 650;
      padding: 0 10px;
      cursor: default;
    }
    .speedValue.on{
      border-color:var(--blue);
      box-shadow: 0 0 0 3px rgba(43,124,255,.12) inset;
    }

    #fpBody{
      padding: 10px 12px 12px 12px;
      box-shadow: inset 0 1px 0 rgba(0,0,0,.05);
    }

    #status{
      margin: 8px 2px 0 2px;
      color: var(--muted);
      font-size: .92rem;
      line-height: 1.05;
    }

    .plyr--audio .plyr__controls{
      border-radius: 12px;
      flex-wrap: wrap;
      row-gap: 8px;
    }
    .plyr--audio .plyr__controls .plyr__progress{
      flex: 1 1 100%;
      min-width: 0;
    }

    @media (max-width: 680px){
      #fpHeader{ flex-wrap: wrap; gap: 8px; }
      #fpTitle{
        flex: 1 1 100%;
        white-space: normal;
        overflow: visible;
        text-overflow: clip;
      }
      #fpHeaderRight{
        width: 100%;
        justify-content: flex-end;
      }
    }

    .diseaseName{
      color: #c2410c;
      font-weight: 650;
    }

    /* Sidebar */
    #sbOverlay{
      position: fixed;
      left: 0; top: 0;
      width: 100vw;
      height: 100vh;
      z-index: 10020;
      display:none;
      background: rgba(0,0,0,.18);
      -webkit-transform: translateZ(0);
      transform: translateZ(0);
      will-change: transform, width, height;
    }
    #sbOverlay.open{ display:block; }

    #sidebar{
      position: absolute;
      left: max(12px, env(safe-area-inset-left));
      top: max(12px, env(safe-area-inset-top));
      width: min(360px, calc(100vw - 24px));
      height: min(86vh, 720px);
      background: #fff;
      border: 1.5px solid #d6d6d6;
      border-right-color: #bdbdbd;
      border-bottom-color:#b3b3b3;
      border-radius: 18px;
      box-shadow:
        10px 34px 86px rgba(0,0,0,.20),
        4px 14px 30px rgba(0,0,0,.10),
        0px 2px 6px rgba(0,0,0,.06);
      overflow: hidden;
      display:flex;
      flex-direction: column;
    }

    #sbHeader{
      padding: 10px 12px;
      background: #fbfbfb;
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      border-bottom: 1px solid #ececec;
      line-height: 1.05;
    }
    #sbTitle{
      font-weight: 750;
      font-size: 1rem;
      flex: 1 1 auto;
      min-width: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    #sbCloseBtn{
      width: 40px;
      height: 36px;
      border-radius: 12px;
      border: 1px solid #d8d8d8;
      background: white;
      cursor: pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      user-select:none;
    }
    #sbCloseBtn:hover{ background: var(--hover); }

    #sbBody{
      padding: 12px;
      overflow:auto;
      -webkit-overflow-scrolling: touch;
      flex: 1 1 auto;
      background:#fff;
    }

    .sbSection{
      border: 1px solid #e2e2e2;
      border-radius: 16px;
      padding: 10px;
      margin-bottom: 10px;
      background: #fff;
      box-shadow: inset 0 1px 0 rgba(0,0,0,.03);
    }
    .sbSection h3{
      margin: 0 0 8px 0;
      font-size: .95rem;
      color:#111;
    }
    .sbRow{
      display:flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items:center;
    }
    .sbBtn{
      height: 36px;
      padding: 0 12px;
      border-radius: 12px;
      border: 1px solid #d8d8d8;
      background: white;
      cursor: pointer;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      font-weight: 650;
      font-size: .92rem;
      user-select:none;
      line-height: 1;
    }
    .sbBtn:hover{ background: var(--hover); }
    .sbBtn.on{
      border-color:var(--blue);
      background: rgba(43,124,255,.10);
      box-shadow: 0 0 0 3px rgba(43,124,255,.12) inset;
    }
    .sbHint{
      color: var(--muted);
      font-size: .9rem;
      line-height: 1.2;
      margin-top: 6px;
    }

    /* Transcript popup */

    #txPanel{
      position: fixed;
      z-index: 10050;
      top: max(14px, env(safe-area-inset-top));
      right: max(14px, env(safe-area-inset-right));
      width: min(960px, calc(100vw - 28px));
      height: min(82vh, 860px);
      background: #fff;
      border: 1.5px solid #d6d6d6;
      border-right-color: #bdbdbd;
      border-bottom-color:#b3b3b3;
      border-radius: 18px;
      box-shadow:
        10px 34px 86px rgba(0,0,0,.20),
        4px 14px 30px rgba(0,0,0,.10),
        0px 2px 6px rgba(0,0,0,.06);
      overflow: hidden;
      display: none;
      flex-direction: column;
      touch-action: none;
    }

    #txPanel.open{ display: flex; }

    #txHeader{
      padding: 10px 12px;
      background: #fbfbfb;
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      cursor: grab;
      user-select:none;
      touch-action: none;
      -webkit-tap-highlight-color: transparent;
      border-bottom: 1px solid #ececec;
      line-height: 1.05;
    }

    #txTitle{
      font-weight: 650;
      font-size: .98rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      flex: 1 1 auto;
      min-width: 0;
    }

    #txBtns{
      display:flex;
      gap: 8px;
      flex: 0 0 auto;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .txBtn{
      height: 36px;
      padding: 0 12px;
      border-radius: 12px;
      border: 1px solid #d8d8d8;
      background: white;
      cursor: pointer;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap: 8px;
      font-weight: 650;
      font-size: .92rem;
      user-select:none;
      line-height: 1;
      white-space: nowrap;
    }
    .txBtn:hover{ background: var(--hover); }
    .txBtn:disabled{ opacity: .45; cursor: default; }
    .txBtn svg{ width: 16px; height: 16px; }

    #txBody{
      padding: 10px 12px 12px 12px;
      overflow: auto;
      -webkit-overflow-scrolling: touch;
      flex: 1 1 auto;
      background: #fff;
    }

    #txInfo{
      color: var(--muted);
      font-size: .92rem;
      margin: 0 0 8px 0;
      line-height: 1.05;
    }

    #txSearchRow{
      display: none;
      gap: 8px;
      align-items: center;
      margin: 0 0 10px 0;
      padding: 8px;
      border: 1px solid #e2e2e2;
      border-radius: 14px;
      background: #fff;
      box-shadow: inset 0 1px 0 rgba(0,0,0,.03);
      position: sticky;
      top: 0;
      z-index: 3;
    }
    #txSearchRow.on{ display: flex; }

    #txSearchInput{
      flex: 1 1 auto;
      min-width: 140px;
      height: 46px;
      padding: 0 14px;
      border: 1px solid #d8d8d8;
      border-radius: 14px;
      font-size: 1.05rem;
      outline: none;
    }

    .txNavBtn{
      width: 60px;
      height: 46px;
      border-radius: 14px;
      border: 1px solid #d8d8d8;
      background: white;
      cursor: pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      user-select:none;
      font-weight: 900;
      font-size: 32px;
      line-height: 1;
    }
    .txNavBtn:hover{ background: var(--hover); }
    .txNavBtn:disabled{ opacity: .45; cursor: default; }

    #txMatchCount{
      min-width: 98px;
      text-align: right;
      color: #404040;
      font-variant-numeric: tabular-nums;
      font-size: .92rem;
      user-select:none;
    }

    #txContent{
      white-space: pre-wrap;
      word-break: break-word;
      font-variant-numeric: tabular-nums;
      line-height: 1.35;
      font-size: .92rem;
      margin: 0;
    }

    .txMark{
      background: rgba(43,124,255,.22);
      border-radius: 6px;
      padding: 0 2px;
    }
    .txMark.active{
      background: rgba(245,158,11,.35);
      box-shadow: 0 0 0 2px rgba(245,158,11,.20);
    }

    @media (max-width: 680px){
      #txHeader{ flex-wrap: wrap; gap: 8px; }
      #txTitle{
        flex: 1 1 100%;
        white-space: normal;
        overflow: visible;
        text-overflow: clip;
      }
      #txBtns{ width: 100%; justify-content: flex-end; }
      .txBtn{ height: 34px; padding: 0 10px; font-size: .9rem; }
      #search{ font-size: 16px; }
      #txSearchInput{ font-size: 16px; }
    }

    #txResizeHandle{
      position: absolute;
      left: 0;
      bottom: 0;
      width: 54px;
      height: 54px;
      cursor: nwse-resize;
      display:flex;
      align-items:center;
      justify-content:center;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      touch-action: none;
      background: linear-gradient(135deg, rgba(43,124,255,.0), rgba(43,124,255,.18));
      border-top: 1px solid #e2e2e2;
      border-right: 1px solid #e2e2e2;
      border-top-right-radius: 18px;
      box-shadow:
        inset 0 1px 0 rgba(255,255,255,.90),
        0 6px 16px rgba(0,0,0,.10);
    }
    #txResizeHandle:hover{
      background: linear-gradient(135deg, rgba(43,124,255,.06), rgba(43,124,255,.24));
    }
    #txResizeHandle svg{ width: 22px; height: 22px; opacity: .88; }

    /* Captions: player √ºst√ºnde, max 6 satƒ±r */
    .miniBtn.on{
      border-color: var(--blue);
      background: rgba(43,124,255,.10);
      box-shadow: 0 0 0 3px rgba(43,124,255,.12) inset;
    }
    #captions{
      margin: 0;
      padding: 10px 12px;
      padding-bottom: calc(10px + .55em); /* alt satƒ±r kesilmesin */
      border-radius: 12px;
      border: 2px solid #d3d3d3;
      background: #fafafa;
      white-space: pre-wrap;
      line-height: 1.25;
      font-size: 1.02rem;
      overflow: hidden;
      max-height: calc(1.25em * var(--capLines) + 34px);
      box-shadow: 0 10px 22px rgba(0,0,0,.06);
    }
    #captions.isEmpty{ color: var(--muted); }
    #captions.hidden{ display:none; }

    #captionsDock{
      position: absolute;
      left: 0;
      right: 0;
      bottom: 100%;
      transform: translateY(12px);
      pointer-events: none;
      z-index: 10000;
    }
    #captions{ pointer-events: auto; border-bottom-left-radius: 0; border-bottom-right-radius: 0; }

    /* cc / CC / CCx buttons */
    .ccModeBtn{
      width: auto;
      min-width: 44px;
      padding: 0 10px;
      border-color: var(--blue);
      border-radius: 12px;
    }
    .ccModeBtn .btnMark{
      font-weight: 850;
      font-size: 16px;
      letter-spacing: .3px;
      line-height: 1;
    }
    .ccModeBtn.on{
      border-color: var(--blue);
      background: rgba(43,124,255,.10);
      box-shadow: 0 0 0 3px rgba(43,124,255,.12) inset;
    }
    .ccModeBtn.on .btnMark{ color: var(--orange); }
    .ccModeBtn:not(.on) .btnMark{ color: #404040; }

    .txtBtn{
      width: auto;
      min-width: 54px;
      padding: 0 10px;
      border-radius: 12px;
      border: 1px solid #d8d8d8;
      background: white;
    }
    .txtBtn .btnMark{ font-weight: 850; font-size: 14px; letter-spacing: .2px; }
    .txtBtn.on{
      border-color: var(--blue);
      background: rgba(43,124,255,.10);
      box-shadow: 0 0 0 3px rgba(43,124,255,.12) inset;
    }
    .txtBtn.on .btnMark{ color: var(--orange); }
    .txtBtn:not(.on) .btnMark{ color: #404040; }

    .transcriptDock{
      position: absolute;
      left: 0;
      right: 0;
      bottom: calc(100% + var(--capDockH, 0px));
      transform: translateY(12px);
      z-index: 10002;
      pointer-events: none;
    }
    #transcript{
      pointer-events: auto;
      margin: 0;
      padding: 10px 12px;
      padding-bottom: calc(10px + .55em);
      border-radius: 12px;
      border: 2px solid #cfcfcf;
      background: #ffffff;
      white-space: pre-wrap;
      line-height: 1.25;
      font-size: 0.98rem;
      overflow: auto;
      max-height: min(52vh, 560px);
      box-shadow: 0 14px 30px rgba(0,0,0,.10);
    }
    #transcript.hidden{ display: none; }
    #transcript.isEmpty{ color: var(--muted); }
    /* CC + E button styling */
    #ccBtn, #expBtn{
      border-color: var(--blue);
    }
    #ccBtn .btnMark, #expBtn .btnMark{
      font-weight: 800;
      font-size: 17px;
      letter-spacing: .5px;
      line-height: 1;
    }
    #ccBtn.on .btnMark, #expBtn.on .btnMark{ color: var(--orange); }
    #ccBtn:not(.on) .btnMark, #expBtn:not(.on) .btnMark{ color: #404040; }

  </style>
  </style>
</head>

<body>
  <div id="scrollArea">
    <div id="appScale">
      <div class="pageTitle">
        <span>FSP Audio ‚Äî G√ºncel</span>
        <button id="sidebarOpenBtn" type="button" aria-label="Men√º" title="Men√º">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
            <path d="M4 6h16"/><path d="M4 12h16"/><path d="M4 18h16"/>
          </svg>
        </button>
      </div>

      <nav class="navRow" aria-label="Sayfalar">
        <a class="navLink" href="https://protokolfsp.github.io/fsp-audio/">G√ºncel</a>
        <a class="navLink" href="https://protokolfsp.github.io/FSP2022-23/">2021‚Äì23</a>
        <a class="navLink" href="https://protokolfsp.github.io/All-in-One/">All-in-One</a>
        <a class="navLink" href="https://protokolfsp.github.io/Tlcfsp/">TLC</a>
        <a class="navLink" href="https://protokolfsp.github.io/MenschiB/">MenschiB</a>
        <a class="navLink" href="https://protokolfsp.github.io/FSP_DrYemliha/">DrYemliha Notlarƒ±</a>
        <a class="navLink" href="https://protokolfsp.github.io/FSP-Notlari/">FSP-NOTLARI</a>
      </nav>

      <div id="stickyBar">
        <div class="topbar">
          <input id="search" type="text" placeholder="Arama (√∂r. ACS, DM, PAVK)..." />
          <button id="resetBtn" type="button">Hepsi</button>

          <div class="zoomWrap" aria-label="G√∂r√ºn√ºm">
            <button id="zoomOutBtn" class="zoomBtn zoomOut" type="button" aria-label="K√º√ß√ºlt">
              <svg viewBox="0 0 24 24" aria-hidden="true">
                <circle cx="11" cy="11" r="6"></circle>
                <path d="M20 20l-3.5-3.5"></path>
                <path d="M8.5 11h5"></path>
              </svg>
            </button>

            <button id="zoomInBtn" class="zoomBtn zoomIn" type="button" aria-label="B√ºy√ºt">
              <svg viewBox="0 0 24 24" aria-hidden="true">
                <circle cx="11" cy="11" r="6"></circle>
                <path d="M20 20l-3.5-3.5"></path>
                <path d="M11 8.5v5"></path>
                <path d="M8.5 11h5"></path>
              </svg>
            </button>
          </div>
        </div>

        <div id="meta">G√∂r√ºn…ôn: 0 / Toplam: 0</div>

        <div class="headerRow">
          <div class="colTitle">
            <div class="titleHead">
              <span>Kayƒ±t</span>
              <button id="sortDateBtn" class="sortBtn" type="button" title="Tarihe g√∂re sƒ±rala (dosya sonu)">
                <svg id="sortDateIcon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true"></svg>
              </button>
            </div>
          </div>

          <div class="colDur" style="text-align:right;">
            <div class="durHead">
              <span>S√ºre</span>
              <button id="sortDurBtn" class="sortBtn" type="button" title="S√ºreye g√∂re sƒ±rala">
                <svg id="sortDurIcon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true"></svg>
              </button>
            </div>
          </div>

          <div class="headIconCell">
            <button id="sortPlayBtn" class="sortBtn" type="button" title="Dinlenme sayƒ±sƒ±na g√∂re sƒ±rala">
              <svg class="mainIcon" viewBox="0 0 24 24" aria-hidden="true">
                <path class="iconBlue" d="M3 10v4c0 .55.45 1 1 1h3l5 4V5L7 9H4c-.55 0-1 .45-1 1z"/>
                <path class="iconOrange" d="M16.5 8.5a1 1 0 0 1 1.4.1c1 1.2 1.6 2.7 1.6 4.4s-.6 3.2-1.6 4.4a1 1 0 1 1-1.5-1.3c.7-.9 1.1-2 1.1-3.1s-.4-2.2-1.1-3.1a1 1 0 0 1 .1-1.4z"/>
              </svg>
              <svg id="sortPlayIcon" class="dirIcon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true"></svg>
            </button>
          </div>

          <div class="headIconCell">
            <button id="filterFav" class="filterBtn" title="Favoriler filtrele" type="button" aria-pressed="false">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                <path d="M12 2l3.1 6.3 6.9 1-5 4.9 1.2 6.8L12 17.8 5.8 21l1.2-6.8-5-4.9 6.9-1L12 2z"/>
              </svg>
            </button>
          </div>

          <div class="headIconCell" aria-hidden="true"></div>

          <div class="headIconCell">
            <button id="sortDlCountBtn" class="sortBtn" type="button" title="ƒ∞ndirme sayƒ±sƒ±na g√∂re sƒ±rala">
              <svg class="mainIcon" viewBox="0 0 24 24" aria-hidden="true">
                <path class="iconBlue" d="M4 3h12l4 4v14a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2z"/>
                <path class="iconOrange" d="M7 3h8v6H7V3zm4 10.2a3.3 3.3 0 1 0 0 6.6 3.3 3.3 0 0 0 0-6.6z"/>
              </svg>
              <svg id="sortDlCountIcon" class="dirIcon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true"></svg>
            </button>
          </div>

          <div class="headIconCell">
            <span class="txtHead" title="Transkript">TXT</span>
          </div>
        </div>
      </div>

      <div id="stickyBarPh" aria-hidden="true"></div>

      <div id="list"></div>
      <div id="status"></div>
    </div>
  </div>

  <!-- Sidebar -->
  <div id="sbOverlay" aria-hidden="true">
    <div id="sidebar" role="dialog" aria-label="Men√º">
      <div id="sbHeader">
        <div id="sbTitle">Men√º</div>
        <button id="sbCloseBtn" type="button" aria-label="Kapat" title="Kapat">‚úï</button>
      </div>
      <div id="sbBody">
        <div class="sbSection">
          <h3>Hƒ±zlƒ±</h3>
          <div class="sbRow">
            <button id="sbRefreshBtn" class="sbBtn" type="button">Listeyi Yenile</button>
            <button id="sbZoomResetBtn" class="sbBtn" type="button">Zoom 100%</button>
          </div>
          <div class="sbHint">Listeyi yenile: Archive.org metadata tekrar okunur. (refresh parametresi yok)</div>
        </div>

        <div class="sbSection">
          <h3>Filtre / Sƒ±ralama</h3>
          <div class="sbRow">
            <button id="sbFavBtn" class="sbBtn" type="button">Favoriler</button>
          </div>
          <div class="sbRow" style="margin-top:8px;">
            <button id="sbSortDateBtn" class="sbBtn" type="button">Tarih</button>
            <button id="sbSortDurBtn" class="sbBtn" type="button">S√ºre</button>
            <button id="sbSortPlayBtn" class="sbBtn" type="button">Dinlenme</button>
            <button id="sbSortDlBtn" class="sbBtn" type="button">ƒ∞ndirme</button>
          </div>
          <div class="sbHint">Sƒ±ralama butonu: modu se√ßer. Aynƒ± moda tekrar basarsan y√∂n deƒüi≈üir.</div>
        </div>

        <div class="sbSection">
          <h3>Transkript</h3>
          <div class="sbRow">
            <button id="sbClearTxCacheBtn" class="sbBtn" type="button">TXT Cache Temizle</button>
          </div>
          <div class="sbHint">TXT‚Äôler sadece tƒ±klandƒ±ƒüƒ±nda y√ºklenir. Cache temizle: popup tekrar indirir.</div>
        </div>
      </div>
    </div>
  </div>

  <div id="floatingPlayer" role="region" aria-label="Oynatƒ±cƒ±">
    <div id="transcriptDock" class="transcriptDock" aria-label="Metin (TXT)">
      <div id="transcript" class="hidden isEmpty" aria-live="polite"></div>
    </div>
    <div id="captionsDock" aria-label="Altyazƒ±lar">
      <div id="captions" class="isEmpty" aria-live="polite">Bir kayƒ±t se√ß...</div>
    </div>
    <div id="fpHeader" title="S√ºr√ºkle">
      <div id="fpTitle">Bir kayƒ±t se√ß...</div>
      <div id="fpHeaderRight">
        <button id="ccSmallBtn" class="miniBtn ccModeBtn" type="button" title="Altyazƒ± (cc)" aria-pressed="false" aria-label="Altyazƒ± (cc)">
          <span class="btnMark">cc</span>
        </button>
        <button id="ccMedBtn" class="miniBtn ccModeBtn" type="button" title="Altyazƒ± (CC)" aria-pressed="false" aria-label="Altyazƒ± (CC)">
          <span class="btnMark">CC</span>
        </button>
        <button id="ccXBtn" class="miniBtn ccModeBtn" type="button" title="Altyazƒ± (CCx)" aria-pressed="false" aria-label="Altyazƒ± (CCx)">
          <span class="btnMark">CCx</span>
        </button>
        <button id="txtBtn" class="miniBtn txtBtn" type="button" title="Metin (TXT)" aria-pressed="false" aria-label="Metin (TXT)">
          <span class="btnMark">TXT</span>
        </button>

<div id="speedWrap" class="speedWrap" aria-label="Hƒ±z">
          <button id="slowBtn" class="speedCtlBtn" type="button" title="Yava≈ülat (üê¢)">üê¢</button>
          <div id="speedValue" class="speedValue on" title="Oynatma hƒ±zƒ±">1√ó</div>
          <button id="fastBtn" class="speedCtlBtn" type="button" title="Hƒ±zlandƒ±r (üêá)">üêá</button>
        </div>

        <button id="prevBtn" class="miniBtn" type="button" title="√ñnceki">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
            <path d="M19 20L9 12l10-8v16z"/><path d="M5 19V5"/>
          </svg>
        </button>
        <button id="nextBtn" class="miniBtn" type="button" title="Sonraki">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
            <path d="M5 4l10 8-10 8V4z"/><path d="M19 5v14"/>
          </svg>
        </button>
      </div>
    </div>
    <div id="fpBody">
      <audio id="player" class="js-player" controls preload="metadata"></audio>
    </div>
  </div>

  <!-- Transcript popup -->
    <div id="txPanel" role="dialog" aria-label="Transkript" aria-hidden="true">
      <div id="txHeader">
        <div id="txTitle">Transkript</div>
        <div id="txBtns">
          <button id="txCopyBtn" class="txBtn" type="button" title="Kopieren">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
              <path d="M9 9h10v10H9z"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
            </svg>
            Kopieren
          </button>
          <button id="txDownloadBtn" class="txBtn" type="button" title="Download">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
              <path d="M12 3v12"/><path d="M7 10l5 5 5-5"/><path d="M5 21h14"/>
            </svg>
            Download
          </button>
          <button id="txSearchBtn" class="txBtn" type="button" title="Suchen">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
              <circle cx="11" cy="11" r="6"></circle>
              <path d="M20 20l-3.5-3.5"></path>
            </svg>
            Suchen
          </button>
          <button id="txCloseBtn" class="txBtn" type="button" title="Schlie√üen">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
              <path d="M18 6L6 18"/><path d="M6 6l12 12"/>
            </svg>
            Schlie√üen
          </button>
        </div>
      </div>

      <div id="txBody">
        <div id="txInfo">‚Äî</div>

        <div id="txSearchRow" aria-label="Suchen">
          <input id="txSearchInput" type="text" placeholder="Suchen‚Ä¶" />
          <button id="txPrevMatchBtn" class="txNavBtn" type="button" title="Vorheriger Treffer">‚Äπ</button>
          <button id="txNextMatchBtn" class="txNavBtn" type="button" title="N√§chster Treffer">‚Ä∫</button>
          <div id="txMatchCount" title="Treffer">0/0</div>
        </div>

        <pre id="txContent"></pre>
      </div>

      <div id="txResizeHandle" title="Resize" aria-hidden="true">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
          <path d="M7 17l10-10"/><path d="M11 17h6v-6"/>
        </svg>
      </div>
    </div>

  <script src="https://cdn.plyr.io/3.7.8/plyr.polyfilled.js"></script>

  <script>
    const IA_IDENTIFIER_1 = "vorhofflimmern-bei-bekannter-khk-dr-oemer-dr-remzi-09.05.25";
    const DL_PROXY = "https://fspdownload.protokolfsp.workers.dev/";
    const COUNTER_API = "https://fspdlcounter.protokolfsp.workers.dev";
    const SRT_INDEX_API = "https://api.github.com/repos/protokolFSP/FSPtranskript/contents/transcripts?ref=main";
    const SRT_INDEX_TTL_MS = 24 * 60 * 60 * 1000;
    const SRT_INDEX_LS_KEY = "fsp1.srt.index.v1";
    const SRT_INDEX_LS_AT  = "fsp1.srt.index.at.v1";

    const SRT_BASES = [
      "https://protokolfsp.github.io/FSPtranskript/transcripts/",
      "https://raw.githubusercontent.com/protokolFSP/FSPtranskript/main/transcripts/",
      "https://cdn.jsdelivr.net/gh/protokolFSP/FSPtranskript@main/transcripts/"
    ];
    const CAPTION_MAX_LINES = 6;
    const CAPTION_TARGET_LINES = 3; // cc modu hedef
    const CAPTION_MAX_LINES_9 = 9;
    const CAPTION_MAX_LINES_13 = 13;

    const FORCE_REFRESH = new URLSearchParams(location.search).has("refresh");
    const SRT_DEBUG = new URLSearchParams(location.search).has("srtdebug");
    const SRT_CHECK = new URLSearchParams(location.search).has("srtcheck");

    const IS_SAFARI = (() => {
      const ua = navigator.userAgent || "";
      const isApple = /Mac|iPhone|iPad|iPod/i.test(ua);
      const hasSafari = /Safari/i.test(ua);
      const notChromeLike = !/Chrome|Chromium|CriOS|FxiOS|EdgiOS|Edg|OPR/i.test(ua);
      return isApple && hasSafari && notChromeLike;
    })();

    const scrollArea = document.getElementById("scrollArea");
    const listEl   = document.getElementById("list");
    const searchEl = document.getElementById("search");
    const metaEl   = document.getElementById("meta");
    const statusEl = document.getElementById("status");

    const stickyBar = document.getElementById("stickyBar");
    const stickyPh  = document.getElementById("stickyBarPh");

    const appScaleEl = document.getElementById("appScale");
    const zoomOutBtn = document.getElementById("zoomOutBtn");
    const zoomInBtn  = document.getElementById("zoomInBtn");

    const fp = document.getElementById("floatingPlayer");
    const fpHeader = document.getElementById("fpHeader");
    const fpTitle = document.getElementById("fpTitle");

    const playerEl = document.getElementById("player");
    const prevBtn = document.getElementById("prevBtn");
    const nextBtn = document.getElementById("nextBtn");

    const slowBtn = document.getElementById("slowBtn");
    const fastBtn = document.getElementById("fastBtn");
    const speedValueEl = document.getElementById("speedValue");
    const ccSmallBtn = document.getElementById("ccSmallBtn");
    const ccMedBtn   = document.getElementById("ccMedBtn");
    const ccXBtn     = document.getElementById("ccXBtn");
    const txtBtn     = document.getElementById("txtBtn");
    const transcriptDock = document.getElementById("transcriptDock");
    const transcriptEl   = document.getElementById("transcript");
    const captionsDock = document.getElementById("captionsDock");
    const captionsEl = document.getElementById("captions");

    const filterFavBtn  = document.getElementById("filterFav");
    const resetBtn      = document.getElementById("resetBtn");

    const sortDurBtn  = document.getElementById("sortDurBtn");
    const sortDurIcon = document.getElementById("sortDurIcon");
    const sortDateBtn  = document.getElementById("sortDateBtn");
    const sortDateIcon = document.getElementById("sortDateIcon");

    const sortPlayBtn  = document.getElementById("sortPlayBtn");
    const sortPlayIcon = document.getElementById("sortPlayIcon");
    const sortDlCountBtn  = document.getElementById("sortDlCountBtn");
    const sortDlCountIcon = document.getElementById("sortDlCountIcon");

    // Sidebar nodes
    const sidebarOpenBtn = document.getElementById("sidebarOpenBtn");
    const sbOverlay = document.getElementById("sbOverlay");
    const sbCloseBtn = document.getElementById("sbCloseBtn");
    const sbRefreshBtn = document.getElementById("sbRefreshBtn");
    const sbZoomResetBtn = document.getElementById("sbZoomResetBtn");
    const sbFavBtn = document.getElementById("sbFavBtn");
    const sbSortDateBtn = document.getElementById("sbSortDateBtn");
    const sbSortDurBtn = document.getElementById("sbSortDurBtn");
    const sbSortPlayBtn = document.getElementById("sbSortPlayBtn");
    const sbSortDlBtn = document.getElementById("sbSortDlBtn");
    const sbClearTxCacheBtn = document.getElementById("sbClearTxCacheBtn");

    // Transcript popup nodes
    const txPanel = document.getElementById("txPanel");
    const txHeader = document.getElementById("txHeader");
    const txResizeHandle = document.getElementById("txResizeHandle");
    const txTitleEl = document.getElementById("txTitle");
    const txInfoEl = document.getElementById("txInfo");
    const txContentEl = document.getElementById("txContent");
    const txBodyEl = document.getElementById("txBody");

    const txCopyBtn = document.getElementById("txCopyBtn");
    const txDownloadBtn = document.getElementById("txDownloadBtn");
    const txSearchBtn = document.getElementById("txSearchBtn");
    const txCloseBtn = document.getElementById("txCloseBtn");

    const txSearchRow = document.getElementById("txSearchRow");
    const txSearchInput = document.getElementById("txSearchInput");
    const txPrevMatchBtn = document.getElementById("txPrevMatchBtn");
    const txNextMatchBtn = document.getElementById("txNextMatchBtn");
    const txMatchCountEl = document.getElementById("txMatchCount");

    const plyr = new Plyr(playerEl, {
      seekTime: 6.5,
      controls: ["rewind","play","fast-forward","progress","current-time","duration","mute","volume"]
    });

    function gaEvent(name, params = {}) {
      try {
        if (typeof gtag !== "function") return;
        gtag("event", name, { ...params, page_path: location.pathname });
      } catch {}
    }
    function trackAudioPlay(it) {
      gaEvent("audio_play", {
        audio_id: it.id,
        audio_title: it.title,
        file_name: (it.name || "").split("/").pop() || "",
        src: it.src || "S1"
      });
    }
    function trackAudioDownload(it, filename) {
      gaEvent("audio_download", {
        audio_id: it.id,
        audio_title: it.title,
        file_name: filename || (it.name || "").split("/").pop() || "",
        src: it.src || "S1"
      });
    }
    function trackTranscriptOpen(it){
      gaEvent("transcript_open", {
        audio_id: it.id,
        audio_title: it.title,
        file_name: (it.txtName || "").split("/").pop() || "",
        src: it.src || "S1"
      });
    }
    function trackTranscriptDownload(it, filename){
      gaEvent("transcript_download", {
        audio_id: it.id,
        audio_title: it.title,
        file_name: filename || (it.txtName || "").split("/").pop() || "",
        src: it.src || "S1"
      });
    }

    let globalPlayCounts = {};
    let globalDownloadCounts = {};

    function chunk(arr, size){
      const out = [];
      for (let i=0; i<arr.length; i+=size) out.push(arr.slice(i, i+size));
      return out;
    }

    async function fetchCounts(type, ids){
      if (!ids.length) return {};
      try{
        const res = await fetch(COUNTER_API + "/counts", {
          method: "POST",
          mode: "cors",
          cache: "no-store",
          headers: {
            "content-type": IS_SAFARI ? "text/plain;charset=utf-8" : "application/json"
          },
          body: JSON.stringify({ type, ids })
        });
        if (!res.ok) throw new Error("counts failed");
        const j = await res.json();
        return (j && j.counts) ? j.counts : {};
      }catch{
        return {};
      }
    }

    let refreshCountsTimer = null;
    function scheduleRefreshCounts(ms = 800){
      clearTimeout(refreshCountsTimer);
      refreshCountsTimer = setTimeout(() => refreshAllCounts().catch(()=>{}), ms);
    }

    async function refreshAllCounts(){
      if (!items.length) return;

      const ids = items.map(it => it.id);
      const parts = chunk(ids, 200);

      const playAll = {};
      const dlAll = {};

      for (const part of parts){
        const [p, d] = await Promise.all([
          fetchCounts("play", part),
          fetchCounts("download", part),
        ]);
        Object.assign(playAll, p);
        Object.assign(dlAll, d);
      }

      const playHas = Object.keys(playAll).length > 0;
      const dlHas   = Object.keys(dlAll).length > 0;

      if (!playHas && !dlHas) return;

      if (playHas) globalPlayCounts = playAll;
      if (dlHas)   globalDownloadCounts = dlAll;

      render();
    }

    function sendHit(type, it){
      try{
        const payload = {
          type,
          id: it?.id || "",
          title: it?.title || "",
          file_name: (it?.name || "").split("/").pop() || ""
        };

        const url = COUNTER_API + "/hit";
        const data = JSON.stringify(payload);

        if (IS_SAFARI && navigator.sendBeacon){
          const ok = navigator.sendBeacon(
            url,
            new Blob([data], { type: "text/plain;charset=utf-8" })
          );
          if (ok) return;
        }

        fetch(url, {
          method: "POST",
          mode: "cors",
          cache: "no-store",
          keepalive: true,
          headers: {
            "content-type": IS_SAFARI ? "text/plain;charset=utf-8" : "application/json"
          },
          body: data
        }).catch(() => {});
      }catch{}
    }

    function bumpLocalGlobalCount(type, id){
      if (!id) return;
      if (type === "play"){
        globalPlayCounts[id] = (Number(globalPlayCounts[id]) || 0) + 1;
      } else {
        globalDownloadCounts[id] = (Number(globalDownloadCounts[id]) || 0) + 1;
      }
    }

    let playGate = { id: null, armed: false, sent: false };
    function armPlayGate(it){
      playGate = { id: it?.id || null, armed: true, sent: false };
    }
    function trySendPlayOnPlaying(){
      if (!playGate.armed || playGate.sent || !playGate.id) return;
      if (!playerEl || playerEl.paused) return;

      playGate.sent = true;
      const it = items.find(x => x.id === playGate.id) || { id: playGate.id, title:"", name:"" };
      bumpLocalGlobalCount("play", it.id);
      sendHit("play", it);
      scheduleRefreshCounts(1200);
      render();
    }
    playerEl.addEventListener("playing", trySendPlayOnPlaying);

    playerEl.addEventListener("error", () => {
      const code = playerEl?.error?.code;
      statusEl.textContent = "Audio hata: " + (code || "bilinmiyor");
    });

    const LS = {
      favs:  "fsp1.favs.v1",
      pos:   "fsp1.fp.pos.v1",
      durs:  "fsp1.durs.v1",
      sortMode: "fsp1.sort.mode.v2",
      sortDirDur: "fsp1.sort.dur.dir.v1",
      sortDirDate: "fsp1.sort.date.dir.v1",
      sortDirPlay: "fsp1.sort.play.dir.v1",
      sortDirDl:   "fsp1.sort.dl.dir.v1",
      speed: "fsp1.speed.v1",
      zoom:  "fsp1.ui.zoom.v1",
      captionsMode: "fsp1.captions.mode.v1",
      transcriptOn: "fsp1.transcript.on.v1",

      itemsCache:   "fsp1.items.cache.s1.v2",
      itemsCacheAt: "fsp1.items.cache.s1.at.v1",
      metaUpdated:  "fsp1.items.meta.updated.s1.v1",
      uiState:      "fsp1.ui.state.v1",

      txSize: "fsp1.tx.size.v1",

      txPos:  "fsp1.tx.pos.v1"
    };

    const loadMap = (k) => { try { return JSON.parse(localStorage.getItem(k) || "{}"); } catch { return {}; } };
    const saveMap = (k, v) => localStorage.setItem(k, JSON.stringify(v));
    const loadAny = (k) => { try { return JSON.parse(localStorage.getItem(k) || "null"); } catch { return null; } };
    const saveAny = (k, v) => localStorage.setItem(k, JSON.stringify(v));

    let favs  = loadMap(LS.favs);
    let durs  = loadMap(LS.durs);

    let filterFav  = false;

    let items = [];
    let activeId = null;
    let selectedId = null;

    const CACHE_TTL_MS = 30 * 24 * 60 * 60 * 1000; // 30 g√ºn
    let pendingScrollTop = null;

    function itemsFingerprint(list){
      if (!Array.isArray(list) || !list.length) return "";
      return list.map(x => String(x?.id || "")).sort().join("|");
    }

    function saveUiState(){
      try{
        saveAny(LS.uiState, {
          q: (searchEl.value || ""),
          filterFav: !!filterFav,
          activeId: (activeId || null),
          selectedId: (selectedId || null),
          scrollTop: Number(scrollArea.scrollTop) || 0
        });
      }catch{}
    }

    function restoreUiState(){
      const s = loadAny(LS.uiState);
      if (!s) return;
      if (typeof s.q === "string") searchEl.value = s.q;
      if (typeof s.filterFav === "boolean") filterFav = s.filterFav;
      if (typeof s.activeId === "string") activeId = s.activeId;
      if (typeof s.selectedId === "string") selectedId = s.selectedId;
      else if (typeof s.activeId === "string") selectedId = s.activeId;
      if (typeof s.scrollTop === "number") pendingScrollTop = s.scrollTop;
    }

    function restoreScrollIfNeeded(){
      if (pendingScrollTop == null) return;
      const v = pendingScrollTop;
      pendingScrollTop = null;
      requestAnimationFrame(() => { scrollArea.scrollTop = v; });
    }

    window.addEventListener("pagehide", saveUiState);
    document.addEventListener("visibilitychange", () => {
      if (document.visibilityState === "hidden") saveUiState();
    });

    let sortMode = localStorage.getItem(LS.sortMode) || "date";
    let durSortDir  = (localStorage.getItem(LS.sortDirDur) === "desc") ? "desc" : "asc";
    let dateSortDir = (localStorage.getItem(LS.sortDirDate) === "asc") ? "asc" : "desc";
    let playSortDir = (localStorage.getItem(LS.sortDirPlay) === "asc") ? "asc" : "desc";
    let dlSortDir   = (localStorage.getItem(LS.sortDirDl) === "asc") ? "asc" : "desc";

    if (!localStorage.getItem(LS.sortMode)) localStorage.setItem(LS.sortMode, sortMode);
    if (!localStorage.getItem(LS.sortDirDate)) localStorage.setItem(LS.sortDirDate, dateSortDir);
    if (!localStorage.getItem(LS.sortDirPlay)) localStorage.setItem(LS.sortDirPlay, playSortDir);
    if (!localStorage.getItem(LS.sortDirDl)) localStorage.setItem(LS.sortDirDl, dlSortDir);

    const SPEEDS = [0.5, 0.75, 0.9, 1, 1.25, 1.5, 1.75, 2.0, 2.25];
    let speedIndex = SPEEDS.indexOf(1);

    function fmtSpeed(v){
      const s = (Math.round(v * 100) / 100).toString();
      return s.replace(/\.0+$/,"") + "√ó";
    }

    function setSpeedUI(v){
      speedValueEl.textContent = fmtSpeed(v);
      speedValueEl.classList.add("on");
      slowBtn.disabled = (speedIndex <= 0);
      fastBtn.disabled = (speedIndex >= SPEEDS.length - 1);
      slowBtn.style.opacity = slowBtn.disabled ? 0.45 : 1;
      fastBtn.style.opacity = fastBtn.disabled ? 0.45 : 1;
    }

    function applySpeedByIndex(idx){
      speedIndex = Math.max(0, Math.min(SPEEDS.length - 1, idx));
      const v = SPEEDS[speedIndex];
      plyr.speed = v;
      localStorage.setItem(LS.speed, String(v));
      setSpeedUI(v);
    }

    function restoreSpeed(){
      const saved = Number(localStorage.getItem(LS.speed) || "1");
      if (Number.isFinite(saved)){
        const i = SPEEDS.findIndex(x => Math.abs(x - saved) < 0.001);
        applySpeedByIndex(i === -1 ? SPEEDS.indexOf(1) : i);
      } else {
        applySpeedByIndex(SPEEDS.indexOf(1));
      }
    }

    slowBtn.addEventListener("click", (e) => { e.stopPropagation(); applySpeedByIndex(speedIndex - 1); });
    fastBtn.addEventListener("click", (e) => { e.stopPropagation(); applySpeedByIndex(speedIndex + 1); });

    const ZOOMS = [0.85, 0.9, 0.95, 1, 1.05, 1.1, 1.15, 1.2];
    let zoomIndex = ZOOMS.indexOf(1);
    let uiScale = 1;
    let useTransformScale = false;

const TX_DEFAULT_SIZE = { w: 720, h: 600 };
const TX_MIN_SIZE = { w: 280, h: 220 };

const IOS_MIN_INPUT_PX = 16;

function isIOSWebKit(){
  const ua = navigator.userAgent || "";
  const isAppleTouch = /iP(ad|hone|od)/.test(ua) || (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);
  const isWebKit = /WebKit/.test(ua) && !/Edg|OPR/.test(ua);
  return isAppleTouch && isWebKit;
}

function updateSearchNoZoomFontSizes(){
  if (!isIOSWebKit()) return;
  const scale = Math.max(0.01, uiScale);
  const required = Math.ceil(IOS_MIN_INPUT_PX / scale);
  const inputs = [document.getElementById("search"), document.getElementById("txSearchInput")].filter(Boolean);
  for (const el of inputs){
    if (!el.dataset.baseFontPx){
      const base = parseFloat(getComputedStyle(el).fontSize || "16");
      el.dataset.baseFontPx = String(Number.isFinite(base) ? base : 16);
    }
    const basePx = parseFloat(el.dataset.baseFontPx) || IOS_MIN_INPUT_PX;
    el.style.fontSize = Math.max(basePx, required) + "px";
  }
}

    function getViewportWH(){
      const vv = window.visualViewport;
      const vw = (vv && vv.width)  ? vv.width  : window.innerWidth;
      const vh = (vv && vv.height) ? vv.height : window.innerHeight;
      return { vw, vh };
    }

    function toLayoutPx(v){
      return useTransformScale ? (v / uiScale) : v;
    }

    function updateOverlayScale(){
      if (!useTransformScale){
        sbOverlay.style.transform = "";
        sbOverlay.style.width = "100vw";
        sbOverlay.style.height = "100vh";

        txPanel.style.transform = "";
        txPanel.style.transformOrigin = "top right";
        return;
      }

      const { vw, vh } = getViewportWH();
      const vwL = toLayoutPx(vw);
      const vhL = toLayoutPx(vh);

      sbOverlay.style.transformOrigin = "top left";
      sbOverlay.style.transform = `scale(${uiScale})`;
      sbOverlay.style.width = vwL + "px";
      sbOverlay.style.height = vhL + "px";

      txPanel.style.transformOrigin = "top right";
      txPanel.style.transform = `scale(${uiScale})`;
    }

    function setZoomUI(v){
      const pct = Math.round(v * 100) + "%";
      zoomOutBtn.disabled = (zoomIndex <= 0);
      zoomInBtn.disabled  = (zoomIndex >= ZOOMS.length - 1);

      zoomOutBtn.classList.toggle("enabled", !zoomOutBtn.disabled);
      zoomInBtn.classList.toggle("enabled", !zoomInBtn.disabled);

      zoomOutBtn.title = `K√º√ß√ºlt (${pct})`;
      zoomInBtn.title  = `B√ºy√ºt (${pct})`;
      zoomOutBtn.setAttribute("aria-label", `K√º√ß√ºlt (${pct})`);
      zoomInBtn.setAttribute("aria-label", `B√ºy√ºt (${pct})`);
    }

    function applyZoomByIndex(idx){
      zoomIndex = Math.max(0, Math.min(ZOOMS.length - 1, idx));
      const v = ZOOMS[zoomIndex];
      uiScale = v;

      useTransformScale = !(window.CSS && CSS.supports && CSS.supports("zoom", "1"));

      if (!useTransformScale){
        document.documentElement.style.zoom = String(v);
        appScaleEl.style.transform = "";
        fp.style.transform = "";
      } else {
        document.documentElement.style.zoom = "";
        appScaleEl.style.transform = `scale(${v})`;
        fp.style.transform = `scale(${v})`;
      }

      restorePlayerPos();

      localStorage.setItem(LS.zoom, String(v));
      setZoomUI(v);

      setTimeout(() => {
        clampPlayerToViewport();
        updateSticky(true);
      }, 0);

      updateOverlayScale();
      updateSearchNoZoomFontSizes();
      clampTxSizeToViewport();
      clampTxPosToViewport();
    }

    function restoreZoom(){
      const saved = Number(localStorage.getItem(LS.zoom) || "1");
      if (Number.isFinite(saved)){
        const i = ZOOMS.findIndex(x => Math.abs(x - saved) < 0.001);
        applyZoomByIndex(i === -1 ? ZOOMS.indexOf(1) : i);
      } else {
        applyZoomByIndex(ZOOMS.indexOf(1));
      }
    }

    function resetZoom100(){ applyZoomByIndex(ZOOMS.indexOf(1)); }

    function attachDoubleTapReset(el){
      el.addEventListener("dblclick", (e) => { e.preventDefault(); resetZoom100(); });
      let lastTap = 0;
      el.addEventListener("touchend", (e) => {
        const now = Date.now();
        if (now - lastTap < 320){
          e.preventDefault();
          resetZoom100();
          lastTap = 0;
          return;
        }
        lastTap = now;
      }, { passive: false });
    }

    zoomOutBtn.addEventListener("click", (e) => { e.stopPropagation(); applyZoomByIndex(zoomIndex - 1); });
    zoomInBtn.addEventListener("click", (e) => { e.stopPropagation(); applyZoomByIndex(zoomIndex + 1); });
    attachDoubleTapReset(zoomOutBtn);
    attachDoubleTapReset(zoomInBtn);

    function setTypingMode(on){ fp.classList.toggle("hiddenWhileTyping", !!on); }

    function setMomentumScroll(el, on){
      try { if (el) el.style.webkitOverflowScrolling = on ? "auto" : "touch"; } catch {}
    }

    searchEl.addEventListener("focus", () => { setTypingMode(true); setMomentumScroll(scrollArea, true); });
    searchEl.addEventListener("blur",  () => { setTypingMode(false); setMomentumScroll(scrollArea, false); });

    txSearchInput.addEventListener("focus", () => setMomentumScroll(txBodyEl, true));
    txSearchInput.addEventListener("blur",  () => setMomentumScroll(txBodyEl, false));

    function escHtml(s){
      return (s ?? "").toString()
        .replace(/&/g,"&amp;")
        .replace(/</g,"&lt;")
        .replace(/>/g,"&gt;")
        .replace(/"/g,"&quot;")
        .replace(/'/g,"&#39;");
    }

    function highlightDisease(title){
      const raw = (title ?? "").toString();
      const m = raw.match(/\b(dr|fr)\b\.?/i);
      if (!m || m.index == null) return escHtml(raw);

      const i = m.index;
      const leftRaw = raw.slice(0, i);
      const leftTrim = leftRaw.trimEnd();
      if (!leftTrim.trim()) return escHtml(raw);

      const trailing = leftRaw.slice(leftTrim.length);
      return `<span class="diseaseName">${escHtml(leftTrim)}</span>${escHtml(trailing)}${escHtml(raw.slice(i))}`;
    }

    function foldTR(s){
      s = (s || "").toString();
      s = s.toLocaleLowerCase("tr");
      s = s.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
      s = s.replace(/ƒ±/g, "i");
      s = s.replace(/\s+/g, " ").trim();
      return s;
    }

    function guessMime(url){
      try{
        const p = new URL(url).pathname.toLowerCase();
        if (p.endsWith(".mp3")) return "audio/mpeg";
        if (p.endsWith(".m4a")) return "audio/mp4";
      }catch{}
      return "audio/*";
    }

    function fmtDur(sec){
      if (!Number.isFinite(sec) || sec <= 0) return "‚Äî";
      sec = Math.round(sec);
      const h = Math.floor(sec / 3600);
      const m = Math.floor((sec % 3600) / 60);
      const s = sec % 60;
      const mm = String(m).padStart(2, "0");
      const ss = String(s).padStart(2, "0");
      if (h > 0) return `${h}:${mm}:${ss}`;
      return `${m}:${ss}`;
    }

    function decodeURIComponentSafe(s){
      try { return decodeURIComponent(s); } catch { return s; }
    }


    // ---- SRT Captions (repo: protokolFSP/FSPtranskript) ----
    const CAPTION_MODES = ["cc", "CC", "CCx"];

    function readCaptionMode(){
      const raw = localStorage.getItem(LS.captionsMode) || "";
      if (CAPTION_MODES.includes(raw)) return raw;

      // migration: eski s√ºr√ºmlerde captionsOn/captionsExpanded vardƒ±
      const oldOn = (localStorage.getItem("fsp1.captions.on.v1") !== "0");
      const oldExp = (localStorage.getItem("fsp1.captions.expanded.v1") === "1");
      if (oldOn) return oldExp ? "CC" : "cc";
      return "cc";
    }

    let captionMode = readCaptionMode(); // "cc" | "CC" | "CCx" | off(null)
    const srtCache = new Map(); // item.id -> cues[]
    let srtCtrl = null;
    let activeCues = [];
    let lastCueIdx = -1;

    function isCaptionsOn(){ return !!captionMode; }

    function getCaptionMaxLines(){
      if (captionMode === "CC") return CAPTION_MAX_LINES_9;
      if (captionMode === "CCx") return CAPTION_MAX_LINES_13;
      return CAPTION_MAX_LINES;
    }

    function getCaptionTargetLines(){
      if (captionMode === "CC") return CAPTION_MAX_LINES_9;
      if (captionMode === "CCx") return CAPTION_MAX_LINES_13;
      return CAPTION_TARGET_LINES;
    }

    function setCaptionUi(){
      const on = isCaptionsOn();

      const setBtn = (btn, active) => {
        if (!btn) return;
        btn.classList.toggle("on", !!active);
        btn.setAttribute("aria-pressed", String(!!active));
      };

      setBtn(ccSmallBtn, captionMode === "cc");
      setBtn(ccMedBtn,   captionMode === "CC");
      setBtn(ccXBtn,     captionMode === "CCx");

      if (captionsEl){
        captionsEl.classList.toggle("hidden", !on);
        captionsEl.style.setProperty("--capLines", String(getCaptionMaxLines()));
        if (!on){
          captionsEl.innerHTML = "";
          captionsEl.classList.add("isEmpty");
        } else if (!captionsEl.innerHTML){
          captionsEl.textContent = "‚Ä¶";
          captionsEl.classList.add("isEmpty");
        }
      }

      if (typeof updateDockVars === "function") requestAnimationFrame(() => updateDockVars());
      setTimeout(() => clampPlayerToViewport(), 0);
    }

    function stripSrtTags(s){
      return (s || "").toString().replace(/<[^>]+>/g, "");
    }

    function srtTimeToSec(raw){
      const s = String(raw || "").trim().replace(",", ".");
      const m = s.match(/^(\d{1,2}):(\d{2}):(\d{2})(\.\d+)?$/);
      if (!m) return null;
      const hh = Number(m[1]), mm = Number(m[2]), ss = Number(m[3]);
      const frac = Number(m[4] || "0");
      if (![hh,mm,ss,frac].every(Number.isFinite)) return null;
      return hh * 3600 + mm * 60 + ss + frac;
    }

    function parseSrtToCues(srtText){
      let t = (srtText || "").replace(/^\uFEFF/, "");
      t = t.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
      const blocks = t.split(/\n{2,}/g);

      const cues = [];
      for (const block of blocks){
        const lines = block.split("\n").map(x => x.trimEnd()).filter(x => x.trim().length > 0);
        if (!lines.length) continue;

        let timeIdx = 0;
        if (/^\d+$/.test(lines[0].trim()) && lines.length >= 2) timeIdx = 1;

        const timeLine = lines[timeIdx] || "";
        const tm = timeLine.match(/(.+?)\s*-->\s*(.+)/);
        if (!tm) continue;

        const start = srtTimeToSec(tm[1]);
        const end = srtTimeToSec((tm[2].split(/\s+/)[0]) || "");
        if (start == null || end == null || !(end > start)) continue;

        const text = stripSrtTags(lines.slice(timeIdx + 1).join("\n")).trim();
        if (!text) continue;

        cues.push({ start, end, text });
      }

      cues.sort((a,b) => a.start - b.start);
      return cues;
    }

    function findCueIdx(cues, t){
      if (!cues.length) return -1;
      let lo = 0, hi = cues.length - 1;
      while (lo <= hi){
        const mid = (lo + hi) >> 1;
        const c = cues[mid];
        if (t < c.start) hi = mid - 1;
        else if (t >= c.end) lo = mid + 1;
        else return mid;
      }
      return -1;
    }

    function escapeHtml(s){
      return (s ?? "").toString()
        .replace(/&/g,"&amp;")
        .replace(/</g,"&lt;")
        .replace(/>/g,"&gt;")
        .replace(/"/g,"&quot;")
        .replace(/'/g,"&#39;");
    }

    function splitCaptionLines(text){
      const t = (text || "").toString().replace(/\r\n/g, "\n").replace(/\r/g, "\n");
      return t.split("\n").map(l => l.trimEnd()).filter(l => l.trim().length > 0);
    }

    function countLinesText(text){
      return splitCaptionLines(text).length;
    }

    function composeCaptionParts(cues, idx){
      if (!cues || idx < 0 || idx >= cues.length) return [];

      const parts = [];
      const target = getCaptionTargetLines();
      const wide = getCaptionMaxLines() > CAPTION_MAX_LINES;

      if (wide){
        const preTarget = Math.max(2, Math.floor(target / 3));
        let preLines = 0;
        let p = idx - 1;
        const stack = [];
        while (p >= 0 && preLines < preTarget){
          const t = cues[p]?.text || "";
          const n = countLinesText(t);
          if (n > 0){
            stack.push({ role: "context", isActive: false, text: t });
            preLines += n;
          }
          p--;
        }
        stack.reverse().forEach(x => parts.push(x));
      } else if (idx > 0){
        parts.push({ role: "context", isActive: false, text: cues[idx - 1]?.text || "" });
      }

      parts.push({ role: "active", isActive: true, text: cues[idx]?.text || "" });

      let total = parts.reduce((a,p) => a + countLinesText(p.text), 0);
      let nidx = idx + 1;

      while (total < target && nidx < cues.length){
        const t = cues[nidx]?.text || "";
        const n = countLinesText(t);
        if (n > 0){
          parts.push({ role: "context", isActive: false, text: t });
          total += n;
        }
        nidx++;
      }

      return parts;
    }

    function trimLinesAroundActive(lines, maxLines){
      if (lines.length <= maxLines) return { lines, activeStart: -1, activeEnd: -1 };

      let activeStart = lines.findIndex(l => l.isActive);
      let activeEnd = lines.length - 1 - [...lines].reverse().findIndex(l => l.isActive);
      if (activeStart < 0) activeStart = activeEnd = Math.floor(lines.length / 2);

      let start = 0;
      let end = lines.length - 1;

      while ((end - start + 1) > maxLines){
        const distTop = activeStart - start;
        const distBot = end - activeEnd;
        if (distTop > distBot) start += 1;
        else end -= 1;
      }

      const sliced = lines.slice(start, end + 1);
      const newActiveStart = Math.max(0, activeStart - start);
      const newActiveEnd = Math.max(newActiveStart, activeEnd - start);

      return { lines: sliced, activeStart: newActiveStart, activeEnd: newActiveEnd };
    }

    function renderCaptionLines(lines){
      if (!captionsEl) return;
      if (!isCaptionsOn()) { captionsEl.innerHTML = ""; return; }

      const maxLines = getCaptionMaxLines();
      captionsEl.style.setProperty("--capLines", String(maxLines));

      const { lines: trimmed, activeStart, activeEnd } = trimLinesAroundActive(lines, maxLines);

      const out = [];
      for (let i = 0; i < trimmed.length; i++){
        const ln = trimmed[i];
        const isActive = !!ln.isActive;

        let dist = 0;
        if (!isActive){
          if (i < activeStart) dist = activeStart - i;
          else if (i > activeEnd) dist = i - activeEnd;
          else dist = 1;
        }

        const opacity = isActive ? 1 : Math.max(0.20, 0.92 - (dist * 0.12));
        const weight = isActive ? 750 : 500;

        out.push(`<span style="opacity:${opacity.toFixed(2)};font-weight:${weight}">${escapeHtml(ln.text)}</span>`);
      }

      const html = out.join("<br>");
      captionsEl.innerHTML = html || "‚Ä¶";
      captionsEl.classList.toggle("isEmpty", !html);
      if (typeof updateDockVars === "function") requestAnimationFrame(() => updateDockVars());
      setTimeout(() => clampPlayerToViewport(), 0);
    }

    function renderCaptionInfo(text){
      if (!captionsEl) return;
      if (!isCaptionsOn()) { captionsEl.innerHTML = ""; return; }
      captionsEl.textContent = text || "‚Ä¶";
      captionsEl.classList.add("isEmpty");
      setTimeout(() => clampPlayerToViewport(), 0);
    }

    function onCaptionsTimeupdate(){
      if (!isCaptionsOn()) return;
      if (!activeCues.length) return;

      const t = Number(playerEl?.currentTime) || 0;
      const idx = findCueIdx(activeCues, t);

      // Sessizlikte kutu kaybolmasƒ±n: √∂nceki caption kalsƒ±n.
      if (idx === -1){
        if (lastCueIdx === -1) renderCaptionInfo("‚Ä¶");
        return;
      }

      if (idx === lastCueIdx) return;
      lastCueIdx = idx;

      const parts = composeCaptionParts(activeCues, idx);
      const flat = [];
      for (const p of parts){
        for (const line of splitCaptionLines(p.text)){
          flat.push({ text: line, isActive: !!p.isActive });
        }
      }

      renderCaptionLines(flat);
    }

    if (playerEl) playerEl.addEventListener("timeupdate", onCaptionsTimeupdate);

    function buildSrtNameCandidates(it){
      const rawName = (it?.name || "").split("/").pop() || "";
      const decoded = decodeURIComponentSafe(rawName);

      const baseDecoded = decoded.replace(/\.(m4a|mp3)$/i, ".srt");
      const baseRaw     = rawName.replace(/\.(m4a|mp3)$/i, ".srt");

      const hasA = /^A\s+/i.test(baseDecoded);
      const aDecoded = hasA ? baseDecoded : ("A " + baseDecoded);
      const aRaw     = hasA ? baseRaw     : ("A " + baseRaw);
      const aUDecoded = hasA ? baseDecoded : ("A_" + baseDecoded);
      const aURaw     = hasA ? baseRaw     : ("A_" + baseRaw);
      const aDDecoded = hasA ? baseDecoded : ("A-" + baseDecoded);
      const aDRaw     = hasA ? baseRaw     : ("A-" + baseRaw);

      const altDecoded  = decoded + ".srt";
      const altRaw      = rawName + ".srt";

      const seen = new Set();
      const out = [];
      for (const n of [baseDecoded, baseRaw, aDecoded, aRaw, aUDecoded, aURaw, aDDecoded, aDRaw, altDecoded, altRaw]){
        const nn = String(n || "").trim();
        if (!nn) continue;
        if (seen.has(nn)) continue;
        seen.add(nn);
        out.push(nn);
      }
      return out;
    }

    async function buildSrtUrlsForItem(it){
      const names = buildSrtNameCandidates(it);
      const urls = [];
      for (const name of names){
        for (const base of SRT_BASES){
          urls.push(base + encodeURIComponent(name));
        }
      }
      return { urls, triedNames: names };
    }

    async function loadSrtForItem(it){
      activeCues = [];
      lastCueIdx = -1;

      if (!isCaptionsOn()) return renderCaptionInfo("");
      if (!it) return renderCaptionInfo("Bir kayƒ±t se√ß...");

      const cached = srtCache.get(it.id);
      if (cached){
        activeCues = cached;
        renderCaptionInfo("‚Ä¶");
        return onCaptionsTimeupdate();
      }

      renderCaptionInfo("Altyazƒ± y√ºkleniyor‚Ä¶");

      try { if (srtCtrl) srtCtrl.abort(); } catch {}
      srtCtrl = new AbortController();

      const built = await buildSrtUrlsForItem(it);
      const urls = built.urls;
      const triedNames = built.triedNames || [];
      let lastUrl = urls[0] || "";

      try{
        let cues = null;
        for (const u of urls){
          lastUrl = u;
          const res = await fetch(u, { cache: "no-store", signal: srtCtrl.signal });
          if (!res.ok) continue;
          const body = await res.text();
          const parsed = parseSrtToCues(body);
          if (parsed && parsed.length){ cues = parsed; break; }
        }
        if (!cues) throw new Error("srt not found");

        srtCache.set(it.id, cues);
        activeCues = cues;
        renderCaptionInfo("‚Ä¶");
        onCaptionsTimeupdate();
      }catch(err){
        if (err && err.name === "AbortError") return;
        if (SRT_DEBUG){
          renderCaptionInfo("SRT yok. Denenen isimler: " + (triedNames.join(" | ") || "-") + "\nSon URL: " + lastUrl);
        } else {
          renderCaptionInfo("Bu kayƒ±tta altyazƒ± yok.");
        }
      }
    }

    function setModeOrToggle(nextMode){
      if (captionMode === nextMode){
        captionMode = null; // off
        localStorage.setItem(LS.captionsMode, "");
      } else {
        captionMode = nextMode;
        localStorage.setItem(LS.captionsMode, nextMode);
      }
      setCaptionUi();

      const it = items.find(x => x.id === activeId);
      if (isCaptionsOn() && it) loadSrtForItem(it).catch(()=>{});
    }

    if (ccSmallBtn){
      ccSmallBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        setModeOrToggle("cc");
      });
    }
    if (ccMedBtn){
      ccMedBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        setModeOrToggle("CC");
      });
    }
    if (ccXBtn){
      ccXBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        setModeOrToggle("CCx");
      });
    }

    // ---- TXT Transcript (repo: protokolFSP/FSPtranskript) ----
    let transcriptOn = (localStorage.getItem(LS.transcriptOn) === "1");
    const txtCache = new Map(); // item.id -> text
    let txtCtrl = null;

    function setTranscriptUi(){
      if (!txtBtn || !transcriptEl) return;
      txtBtn.classList.toggle("on", !!transcriptOn);
      txtBtn.setAttribute("aria-pressed", String(!!transcriptOn));

      transcriptEl.classList.toggle("hidden", !transcriptOn);
      if (!transcriptOn){
        transcriptEl.textContent = "";
        transcriptEl.classList.add("isEmpty");
      } else if (!transcriptEl.textContent){
        transcriptEl.textContent = "‚Ä¶";
        transcriptEl.classList.add("isEmpty");
      }

      // caption y√ºksekliƒüini CSS var ile ilet (stack i√ßin)
      requestAnimationFrame(() => updateDockVars());
      setTimeout(() => clampPlayerToViewport(), 0);
    }

    function buildTxtNameCandidates(it){
      const rawName = (it?.name || "").split("/").pop() || "";
      const decoded = decodeURIComponentSafe(rawName);

      const baseDecoded = decoded.replace(/\.(m4a|mp3)$/i, ".txt");
      const baseRaw     = rawName.replace(/\.(m4a|mp3)$/i, ".txt");

      const spDecoded = baseDecoded.replace(/_/g, " ");
      const spRaw     = baseRaw.replace(/_/g, " ");

      const hasA = /^A\s+/i.test(baseDecoded);
      const aDecoded  = hasA ? baseDecoded : ("A " + baseDecoded);
      const aRaw      = hasA ? baseRaw     : ("A " + baseRaw);
      const aSpDecoded= hasA ? spDecoded   : ("A " + spDecoded);
      const aSpRaw    = hasA ? spRaw       : ("A " + spRaw);

      const altDecoded = decoded + ".txt";
      const altRaw     = rawName + ".txt";

      const seen = new Set();
      const out = [];
      for (const n of [baseDecoded, baseRaw, spDecoded, spRaw, aDecoded, aRaw, aSpDecoded, aSpRaw, altDecoded, altRaw]){
        const nn = String(n || "").trim();
        if (!nn) continue;
        if (seen.has(nn)) continue;
        seen.add(nn);
        out.push(nn);
      }
      return out;
    }

    async function buildTxtUrlsForItem(it){
      const names = buildTxtNameCandidates(it);
      const urls = [];
      for (const name of names){
        for (const base of SRT_BASES){
          urls.push(base + encodeURIComponent(name));
        }
      }
      return { urls, triedNames: names };
    }

    function renderTranscriptInfo(text){
      if (!transcriptEl) return;
      if (!transcriptOn) { transcriptEl.textContent = ""; return; }
      transcriptEl.textContent = text || "‚Ä¶";
      transcriptEl.classList.add("isEmpty");
      requestAnimationFrame(() => updateDockVars());
      setTimeout(() => clampPlayerToViewport(), 0);
    }

    function renderTranscriptText(text){
      if (!transcriptEl) return;
      if (!transcriptOn) { transcriptEl.textContent = ""; return; }
      transcriptEl.textContent = text || "‚Ä¶";
      transcriptEl.classList.toggle("isEmpty", !text);
      requestAnimationFrame(() => updateDockVars());
      setTimeout(() => clampPlayerToViewport(), 0);
    }

    async function loadTxtForItem(it){
      if (!transcriptOn) return;
      if (!it) return renderTranscriptInfo("Bir kayƒ±t se√ß...");

      const cached = txtCache.get(it.id);
      if (typeof cached === "string" && cached.length){
        renderTranscriptText(cached);
        return;
      }

      renderTranscriptInfo("TXT y√ºkleniyor‚Ä¶");

      try { if (txtCtrl) txtCtrl.abort(); } catch {}
      txtCtrl = new AbortController();

      const built = await buildTxtUrlsForItem(it);
      const urls = built.urls;
      const triedNames = built.triedNames || [];
      let lastUrl = urls[0] || "";

      try{
        let body = "";
        for (const u of urls){
          lastUrl = u;
          const res = await fetch(u, { cache: "no-store", signal: txtCtrl.signal });
          if (!res.ok) continue;
          body = await res.text();
          if (body && body.trim().length) break;
        }
        if (!body || !body.trim()) throw new Error("txt not found");

        txtCache.set(it.id, body);
        renderTranscriptText(body);
      }catch(err){
        if (err && err.name === "AbortError") return;
        if (typeof SRT_DEBUG !== "undefined" && SRT_DEBUG){
          renderTranscriptInfo("TXT yok. Denenen isimler: " + (triedNames.join(" | ") || "-") + "\nSon URL: " + lastUrl);
        } else {
          renderTranscriptInfo("Bu kayƒ±tta TXT yok.");
        }
      }
    }

    if (txtBtn){
      txtBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        transcriptOn = !transcriptOn;
        localStorage.setItem(LS.transcriptOn, transcriptOn ? "1" : "0");
        setTranscriptUi();

        const it = items.find(x => x.id === activeId);
        if (transcriptOn && it) loadTxtForItem(it).catch(()=>{});
      });
    }

    function updateDockVars(){
      try{
        const capH = (typeof getTotalDockHeightPx === "function") ? getTotalDockHeightPx() : 0;

      const minX = -w + keepX;
      const maxX = vw - keepX;
      const minY = -h + keepY + capH;
      const maxY = vh - keepY;

      return {
        minX: Math.min(minX, maxX),
        maxX: Math.max(minX, maxX),
        minY: Math.min(minY, maxY),
        maxY: Math.max(minY, maxY),
      };
    }

    function clampPlayerToViewport(){
      const { minX, maxX, minY, maxY } = getPlayerBoundsPx();
      const cur = getPlayerPosPx();

      const nx = Math.min(maxX, Math.max(minX, cur.left));
      const ny = Math.min(maxY, Math.max(minY, cur.top));

      fp.style.left = nx + "px";
      fp.style.top  = ny + "px";
      fp.style.right = "auto";
      fp.style.bottom = "auto";

      savePlayerPos(nx, ny);
    }

    const DRAG_IGNORE_SELECTOR =
      "button, a, input, textarea, select, option, " +
      ".speedWrap, .speedCtlBtn, .miniBtn, " +
      ".plyr__controls, .plyr__control, .plyr__progress, .plyr__seek, .plyr__volume, .plyr__time, .plyr__menu";

    function shouldStartDrag(target){
      return !(target && target.closest && target.closest(DRAG_IGNORE_SELECTOR));
    }

    let dragging = false;
    let startClientX = 0, startClientY = 0;
    let startLeft = 0, startTop = 0;
    let moved = false;
    let suppressClickUntil = 0;

    function getCurrentLeftTopLayout(){
      return getPlayerPosPx();
    }

    fpHeader.addEventListener("pointerdown", (e) => {
      if (!shouldStartDrag(e.target)) return;

      dragging = true;
      moved = false;

      fpHeader.setPointerCapture(e.pointerId);
      fpHeader.style.cursor = "grabbing";

      startClientX = e.clientX;
      startClientY = e.clientY;

      const cur = getCurrentLeftTopLayout();
      startLeft = cur.left;
      startTop  = cur.top;

      fp.style.left = startLeft + "px";
      fp.style.top  = startTop + "px";
      fp.style.bottom = "auto";
      fp.style.right  = "auto";
    });

    fpHeader.addEventListener("pointermove", (e) => {
      if (!dragging) return;

      const dxClient = e.clientX - startClientX;
      const dyClient = e.clientY - startClientY;

      const dx = dxClient;
      const dy = dyClient;

      if (!moved && (Math.abs(dxClient) + Math.abs(dyClient) > 6)) moved = true;

      const { minX, maxX, minY, maxY } = getPlayerBoundsPx();

      const nx = Math.min(maxX, Math.max(minX, startLeft + dx));
      const ny = Math.min(maxY, Math.max(minY, startTop  + dy));

      fp.style.left = nx + "px";
      fp.style.top  = ny + "px";
      savePlayerPos(nx, ny);
    });

    function endDrag(pointerId){
      if (!dragging) return;
      dragging = false;
      fpHeader.style.cursor = "grab";

      try { fpHeader.releasePointerCapture(pointerId); } catch {}
      clampPlayerToViewport();

      if (moved){
        suppressClickUntil = Date.now() + 350;
        moved = false;
      }
    }

    fpHeader.addEventListener("pointerup", (e) => endDrag(e.pointerId));
    fpHeader.addEventListener("pointercancel", (e) => endDrag(e.pointerId));

    fpHeader.addEventListener("click", (e) => {
      if (Date.now() < suppressClickUntil){
        e.preventDefault();
        e.stopPropagation();
      }
    }, true);

    window.addEventListener("resize", () => {
      clampPlayerToViewport();
      updateOverlayScale();
      updateSearchNoZoomFontSizes();
      clampTxSizeToViewport();
      clampTxPosToViewport();
      updateSticky(true);
    });
    window.addEventListener("orientationchange", () => setTimeout(() => {
      clampPlayerToViewport();
      updateOverlayScale();
      updateSearchNoZoomFontSizes();
      clampTxSizeToViewport();
      clampTxPosToViewport();
      updateSticky(true);
    }, 150));
    if (window.visualViewport){
      window.visualViewport.addEventListener("resize", () => {
        clampPlayerToViewport();
        updateOverlayScale();
        updateSearchNoZoomFontSizes();
        clampTxSizeToViewport();
        clampTxPosToViewport();
        updateSticky(true);
      });
    }

    (function disablePullToRefresh(){
      let startY = 0;
      scrollArea.addEventListener("touchstart", (e) => {
        if (!e.touches || !e.touches.length) return;
        startY = e.touches[0].clientY;
      }, { passive: true });

      scrollArea.addEventListener("touchmove", (e) => {
        if (!e.touches || !e.touches.length) return;
        const y = e.touches[0].clientY;

        if (scrollArea.scrollTop <= 0 && y > startY + 4){
          e.preventDefault();
        }
      }, { passive: false });
    })();

    (function setActiveNav(){
      const here = location.href.replace(/\/$/, "");
      document.querySelectorAll(".navRow .navLink").forEach(a => {
        a.classList.remove("on");
        const u = (a.getAttribute("href") || "").replace(/\/$/, "");
        if (!u) return;
        if (here === u || here.startsWith(u + "/")) a.classList.add("on");
      });
    })();

    // Sidebar behavior
    function openSidebar(){
      sbOverlay.classList.add("open");
      sbOverlay.setAttribute("aria-hidden", "false");
      updateOverlayScale();
      setSortIcons();
    }
    function closeSidebar(){
      sbOverlay.classList.remove("open");
      sbOverlay.setAttribute("aria-hidden", "true");
    }
    sidebarOpenBtn.addEventListener("click", (e) => { e.stopPropagation(); openSidebar(); });
    sbCloseBtn.addEventListener("click", (e) => { e.stopPropagation(); closeSidebar(); });
    sbOverlay.addEventListener("click", (e) => {
      if (e.target === sbOverlay) closeSidebar();
    });
    document.getElementById("sidebar").addEventListener("click", (e) => e.stopPropagation());

    sbRefreshBtn.addEventListener("click", async () => {
      const old = localStorage.getItem(LS.itemsCacheAt) || "0";
      localStorage.setItem(LS.itemsCacheAt, "0");
      try{
        await loadItems();
      }finally{
        if (items.length) statusEl.textContent = "";
        else statusEl.textContent = "Kayƒ±t bulunamadƒ±.";
        if (old) localStorage.setItem(LS.itemsCacheAt, String(Date.now()));
      }
    });

    sbZoomResetBtn.addEventListener("click", () => resetZoom100());

    sbFavBtn.addEventListener("click", () => { filterFav = !filterFav; setSortIcons(); render(); });

    function clickSort(kind){
      if (kind === "date"){
        if (sortMode !== "date") sortMode = "date";
        else dateSortDir = (dateSortDir === "asc") ? "desc" : "asc";
        localStorage.setItem(LS.sortMode, sortMode);
        localStorage.setItem(LS.sortDirDate, dateSortDir);
      } else if (kind === "dur"){
        if (sortMode !== "dur") sortMode = "dur";
        else durSortDir = (durSortDir === "asc") ? "desc" : "asc";
        localStorage.setItem(LS.sortMode, sortMode);
        localStorage.setItem(LS.sortDirDur, durSortDir);
      } else if (kind === "play"){
        if (sortMode !== "play") sortMode = "play";
        else playSortDir = (playSortDir === "asc") ? "desc" : "asc";
        localStorage.setItem(LS.sortMode, sortMode);
        localStorage.setItem(LS.sortDirPlay, playSortDir);
      } else if (kind === "download"){
        if (sortMode !== "download") sortMode = "download";
        else dlSortDir = (dlSortDir === "asc") ? "desc" : "asc";
        localStorage.setItem(LS.sortMode, sortMode);
        localStorage.setItem(LS.sortDirDl, dlSortDir);
      }
      setSortIcons();
      render();
    }

    sbSortDateBtn.addEventListener("click", () => clickSort("date"));
    sbSortDurBtn.addEventListener("click", () => clickSort("dur"));
    sbSortPlayBtn.addEventListener("click", () => clickSort("play"));
    sbSortDlBtn.addEventListener("click", () => clickSort("download"));

    // Transcript logic
    let txOpen = false;
    let txCurrent = null;
    let txPlainText = "";
    let txMatches = [];
    let txActiveMatch = -1;
    let txSearchTimer = null;

    const txCache = new Map(); // id -> { text, at }
    const TX_CACHE_TTL_MS = 24 * 60 * 60 * 1000;

    function clearTxSearchUI(){
      txMatches = [];
      txActiveMatch = -1;
      txMatchCountEl.textContent = "0/0";
      txPrevMatchBtn.disabled = true;
      txNextMatchBtn.disabled = true;
      txContentEl.textContent = txPlainText || "";
    }

    function clampTxSizeToViewport(){
      if (!txOpen) return;

      const saved = loadAny(LS.txSize);
      if (saved && typeof saved.w === "number" && typeof saved.h === "number"){
        txPanel.style.width = saved.w + "px";
        txPanel.style.height = saved.h + "px";
      } else {
        txPanel.style.width = TX_DEFAULT_SIZE.w + "px";
        txPanel.style.height = TX_DEFAULT_SIZE.h + "px";
      }

      const { vw, vh } = getViewportWH();
      const vwL = toLayoutPx(vw);
      const vhL = toLayoutPx(vh);

      const margin = 28;
      const maxW = Math.max(TX_MIN_SIZE.w, vwL - margin);
      const maxH = Math.max(TX_MIN_SIZE.h, vhL - margin);

      const curW = txPanel.offsetWidth || TX_DEFAULT_SIZE.w;
      const curH = txPanel.offsetHeight || TX_DEFAULT_SIZE.h;

      const minW = Math.min(maxW, TX_MIN_SIZE.w);
      const minH = Math.min(maxH, TX_MIN_SIZE.h);

      const w = Math.min(maxW, Math.max(minW, curW));
      const h = Math.min(maxH, Math.max(minH, curH));

      txPanel.style.width = w + "px";
      txPanel.style.height = h + "px";

      saveAny(LS.txSize, { w, h });
    }

    function getTxPosPx(){
      const cs = getComputedStyle(txPanel);
      const top = parseFloat(txPanel.style.top || cs.top || "0");
      const right = parseFloat(txPanel.style.right || cs.right || "0");
      return { top: Number.isFinite(top) ? top : 0, right: Number.isFinite(right) ? right : 0 };
    }

    function setTxPosPx(top, right){
      txPanel.style.top = top + "px";
      txPanel.style.right = right + "px";
      txPanel.style.left = "auto";
      txPanel.style.bottom = "auto";
    }

    function saveTxPos(top, right){
      saveAny(LS.txPos, { top, right });
    }

    function restoreTxPos(){
      const saved = loadAny(LS.txPos);
      if (!saved) return;
      if (typeof saved.top === "number" && typeof saved.right === "number"){
        setTxPosPx(saved.top, saved.right);
      }
    }

    function clampTxPosCandidate(top, right){
      const { vw, vh } = getViewportWH();
      const rect = txPanel.getBoundingClientRect();
      const w = rect.width;
      const h = rect.height;

      const margin = 14;
      const minTop = margin;
      const maxTop = Math.max(minTop, vh - h - margin);

      const minRight = margin;
      const maxRight = Math.max(minRight, vw - w - margin);

      return {
        top: Math.min(maxTop, Math.max(minTop, top)),
        right: Math.min(maxRight, Math.max(minRight, right)),
      };
    }

    function clampTxPosToViewport(){
      if (!txOpen) return;
      const cur = getTxPosPx();
      const cl = clampTxPosCandidate(cur.top, cur.right);
      setTxPosPx(cl.top, cl.right);
      saveTxPos(cl.top, cl.right);
    }

    function openTranscript(){
      txOpen = true;
      txPanel.classList.add("open");
      txPanel.setAttribute("aria-hidden", "false");
      updateOverlayScale();
      updateSearchNoZoomFontSizes();
      restoreTxPos();
      clampTxSizeToViewport();
      clampTxPosToViewport();
    }

    function closeTranscript(){
      txOpen = false;
      txPanel.classList.remove("open");
      txPanel.setAttribute("aria-hidden", "true");
      txSearchRow.classList.remove("on");
    }

    txCloseBtn.addEventListener("click", () => closeTranscript());

    function escapeForRegex(s){
      return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }

    function buildHighlightedHtml(text, ranges, activeIdx){
      if (!ranges.length) return escHtml(text);
      const parts = [];
      let last = 0;
      for (let i=0; i<ranges.length; i++){
        const r = ranges[i];
        const a = Math.max(0, r[0]);
        const b = Math.max(a, r[1]);
        if (a > last) parts.push(escHtml(text.slice(last, a)));
        const cls = (i === activeIdx) ? "txMark active" : "txMark";
        parts.push(`<span class="${cls}" data-mi="${i}">${escHtml(text.slice(a, b))}</span>`);
        last = b;
      }
      if (last < text.length) parts.push(escHtml(text.slice(last)));
      return parts.join("");
    }

    function computeMatches(text, q){
      const out = [];
      if (!q) return out;
      const re = new RegExp(escapeForRegex(q), "gi");
      let m;
      while ((m = re.exec(text))){
        const a = m.index;
        const b = a + (m[0] || "").length;
        if (b > a) out.push([a, b]);
        if (out.length >= 2000) break;
        if (m[0].length === 0) re.lastIndex++;
      }
      return out;
    }

    function applyTxSearch(){
      const q = (txSearchInput.value || "").trim();
      if (!q){
        clearTxSearchUI();
        return;
      }
      txMatches = computeMatches(txPlainText, q);
      txActiveMatch = txMatches.length ? 0 : -1;

      txPrevMatchBtn.disabled = txMatches.length < 2;
      txNextMatchBtn.disabled = txMatches.length < 2;

      txMatchCountEl.textContent = txMatches.length ? `1/${txMatches.length}` : `0/0`;

      txContentEl.innerHTML = buildHighlightedHtml(txPlainText, txMatches, txActiveMatch);

      if (txMatches.length){
        setTimeout(() => scrollToActiveMatch(), 0);
      }
    }

    function scrollToActiveMatch(){
      const el = txContentEl.querySelector(".txMark.active");
      if (!el) return;
      try{
        el.scrollIntoView({ block: "center", inline: "nearest", behavior: "smooth" });
      }catch{
        el.scrollIntoView();
      }
    }

    function setActiveMatch(idx){
      if (!txMatches.length) return;
      txActiveMatch = ((idx % txMatches.length) + txMatches.length) % txMatches.length;
      txMatchCountEl.textContent = `${txActiveMatch + 1}/${txMatches.length}`;

      const old = txContentEl.querySelector(".txMark.active");
      if (old) old.classList.remove("active");
      const next = txContentEl.querySelector(`.txMark[data-mi="${txActiveMatch}"]`);
      if (next){
        next.classList.add("active");
        scrollToActiveMatch();
      }else{
        txContentEl.innerHTML = buildHighlightedHtml(txPlainText, txMatches, txActiveMatch);
        setTimeout(() => scrollToActiveMatch(), 0);
      }
    }

    txSearchBtn.addEventListener("click", () => {
      const on = txSearchRow.classList.toggle("on");
      if (on){
        txSearchInput.focus();
        txSearchInput.select();
      }
    });

    txSearchInput.addEventListener("input", () => {
      clearTimeout(txSearchTimer);
      txSearchTimer = setTimeout(applyTxSearch, 180);
    });

    txSearchInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter"){
        e.preventDefault();
        if (!txMatches.length){
          applyTxSearch();
          return;
        }
        if (e.shiftKey) setActiveMatch(txActiveMatch - 1);
        else setActiveMatch(txActiveMatch + 1);
      } else if (e.key === "Escape"){
        e.preventDefault();
        txSearchRow.classList.remove("on");
      }
    });

    txPrevMatchBtn.addEventListener("click", () => setActiveMatch(txActiveMatch - 1));
    txNextMatchBtn.addEventListener("click", () => setActiveMatch(txActiveMatch + 1));

    async function copyToClipboard(text){
      if (!text) return false;
      try{
        await navigator.clipboard.writeText(text);
        return true;
      }catch{}
      try{
        const ta = document.createElement("textarea");
        ta.value = text;
        ta.style.position = "fixed";
        ta.style.left = "-9999px";
        ta.style.top = "-9999px";
        document.body.appendChild(ta);
        ta.focus();
        ta.select();
        const ok = document.execCommand("copy");
        ta.remove();
        return !!ok;
      }catch{
        return false;
      }
    }

    txCopyBtn.addEventListener("click", async () => {
      const ok = await copyToClipboard(txPlainText);
      txInfoEl.textContent = ok ? "Kopiert." : "Kopieren fehlgeschlagen.";
      setTimeout(() => {
        if (txCurrent) updateTxInfo(txCurrent);
      }, 1200);
    });

    txDownloadBtn.addEventListener("click", () => {
      if (!txCurrent || !txCurrent.txtUrl) return;
      const filename = (txCurrent.txtName || "").split("/").pop() || "transkript.txt";
      forceDownload(txCurrent.txtUrl, filename);
      trackTranscriptDownload(txCurrent, filename);
    });

    function updateTxInfo(it){
      const file = (it?.txtName || "").split("/").pop() || "‚Äî";
      txInfoEl.textContent = file ? `TXT: ${file}` : "‚Äî";
    }

    async function fetchTranscriptText(it){
      const cached = txCache.get(it.id);
      if (cached && (Date.now() - cached.at) < TX_CACHE_TTL_MS) return cached.text;

      const res = await fetch(it.txtUrl, { cache: "no-cache" });
      if (!res.ok) throw new Error("txt fetch failed");
      const text = await res.text();
      txCache.set(it.id, { text, at: Date.now() });
      return text;
    }

    async function openTranscriptFor(it){
      if (!it || !it.txtUrl) return;
      txCurrent = it;
      openTranscript();
      trackTranscriptOpen(it);

      txTitleEl.textContent = it.title || "Transkript";
      updateTxInfo(it);

      txCopyBtn.disabled = true;
      txDownloadBtn.disabled = false;
      txContentEl.textContent = "Y√ºkleniyor‚Ä¶";
      txPlainText = "";
      clearTxSearchUI();

      try{
        const t = await fetchTranscriptText(it);
        txPlainText = t || "";
        txCopyBtn.disabled = !txPlainText;
        clearTxSearchUI();
      }catch{
        txContentEl.textContent = "TXT y√ºklenemedi.";
        txCopyBtn.disabled = true;
      }
    }

    sbClearTxCacheBtn.addEventListener("click", () => {
      txCache.clear();
      txInfoEl.textContent = "TXT Cache temizlendi.";
      setTimeout(() => {
        if (txCurrent) updateTxInfo(txCurrent);
      }, 1200);
    });

    // Transcript overlay should NOT close on background click.
    txPanel.addEventListener("click", (e) => e.stopPropagation());

// Draggable transcript panel (floating)
const TX_DRAG_IGNORE_SELECTOR = "button, a, input, textarea, select, option";
function shouldStartTxDrag(target){
  return !(target && target.closest && target.closest(TX_DRAG_IGNORE_SELECTOR));
}

let txDragging = false;
let txDragStartX = 0, txDragStartY = 0;
let txDragStartTop = 0, txDragStartRight = 0;

txHeader.addEventListener("pointerdown", (e) => {
  if (!txOpen) return;
  if (!shouldStartTxDrag(e.target)) return;

  txDragging = true;
  txHeader.setPointerCapture(e.pointerId);
  txHeader.style.cursor = "grabbing";

  txDragStartX = e.clientX;
  txDragStartY = e.clientY;

  const cur = getTxPosPx();
  txDragStartTop = cur.top;
  txDragStartRight = cur.right;

  e.preventDefault();
  e.stopPropagation();
});

txHeader.addEventListener("pointermove", (e) => {
  if (!txDragging) return;

  const dx = e.clientX - txDragStartX;
  const dy = e.clientY - txDragStartY;

  const cl = clampTxPosCandidate(txDragStartTop + dy, txDragStartRight - dx);
  setTxPosPx(cl.top, cl.right);

  e.preventDefault();
});

function endTxDrag(pointerId){
  if (!txDragging) return;
  txDragging = false;
  txHeader.style.cursor = "grab";
  try{ txHeader.releasePointerCapture(pointerId); }catch{}
  clampTxPosToViewport();
}

txHeader.addEventListener("pointerup", (e) => endTxDrag(e.pointerId));
txHeader.addEventListener("pointercancel", (e) => endTxDrag(e.pointerId));

    // Resizable transcript panel
    let txResizing = false;
    let txResizeStartX = 0, txResizeStartY = 0;
    let txResizeStartW = 0, txResizeStartH = 0;

    function saveTxSize(w, h){
      saveAny(LS.txSize, { w, h });
    }

    function clampTxSize(w, h){
      const { vw, vh } = getViewportWH();
      const vwL = toLayoutPx(vw);
      const vhL = toLayoutPx(vh);

      const margin = 28;
      const maxW = Math.max(TX_MIN_SIZE.w, vwL - margin);
      const maxH = Math.max(TX_MIN_SIZE.h, vhL - margin);

      const minW = Math.min(maxW, TX_MIN_SIZE.w);
      const minH = Math.min(maxH, TX_MIN_SIZE.h);

      const cw = Math.min(maxW, Math.max(minW, w));
      const ch = Math.min(maxH, Math.max(minH, h));
      return { w: cw, h: ch };
    }

    txResizeHandle.addEventListener("pointerdown", (e) => {
      if (!txOpen) return;
      txResizing = true;
      txResizeStartX = e.clientX;
      txResizeStartY = e.clientY;
      txResizeStartW = txPanel.offsetWidth;
      txResizeStartH = txPanel.offsetHeight;
      txResizeHandle.setPointerCapture(e.pointerId);
      e.preventDefault();
      e.stopPropagation();
    });

    txResizeHandle.addEventListener("pointermove", (e) => {
      if (!txResizing) return;

      const dxClient = e.clientX - txResizeStartX;
      const dyClient = e.clientY - txResizeStartY;

      const dx = useTransformScale ? (dxClient / uiScale) : dxClient;
      const dy = useTransformScale ? (dyClient / uiScale) : dyClient;

      const w = txResizeStartW - dx; // handle is bottom-left
      const h = txResizeStartH + dy;

      const cl = clampTxSize(w, h);
      txPanel.style.width = cl.w + "px";
      txPanel.style.height = cl.h + "px";
      saveTxSize(cl.w, cl.h);
    });

    function endTxResize(pointerId){
      if (!txResizing) return;
      txResizing = false;
      try{ txResizeHandle.releasePointerCapture(pointerId); }catch{}
      clampTxSizeToViewport();
      clampTxPosToViewport();
    }

    txResizeHandle.addEventListener("pointerup", (e) => endTxResize(e.pointerId));
    txResizeHandle.addEventListener("pointercancel", (e) => endTxResize(e.pointerId));

    // Init
    setSortIcons();
    restoreUiState();
    restorePlayerPos();
    restoreSpeed();
    restoreZoom();
    setCaptionUi();
    updateOverlayScale();
    requestAnimationFrame(() => {
      measureStickyStartTop();
      updateSticky(true);
    });

    async function checkSrtAvailability(){
      if (!SRT_CHECK || !items.length) return;

      const maxN = Math.min(items.length, 350);
      const subset = items.slice(0, maxN);

      let missing = 0;
      let checked = 0;

      const concurrency = 8;
      const q = subset.slice();

      async function headOk(url){
        try{
          const r = await fetch(url, { method: "HEAD", cache: "no-store" });
          if (r.ok) return true;
        }catch{}
        try{
          const r = await fetch(url, { method: "GET", cache: "no-store", headers: { "range": "bytes=0-1" } });
          return r.ok;
        }catch{
          return false;
        }
      }

      async function worker(){
        while (q.length){
          const it = q.shift();
          const urls = buildSrtUrlsForItem(it);
          let ok = false;
          for (const u of urls){
            if (await headOk(u)){ ok = true; break; }
          }
          checked++;
          if (!ok){
            missing++;
            console.warn("SRT eksik:", it.title, it.name);
          }
          if (checked % 25 === 0){
            statusEl.textContent = `SRT kontrol: ${checked}/${maxN} (eksik: ${missing})`;
          }
        }
      }

      await Promise.all(Array.from({ length: concurrency }, () => worker()));
      statusEl.textContent = `SRT kontrol bitti: ${checked}/${maxN} (eksik: ${missing})`;
    }

    setTimeout(clampPlayerToViewport, 0);
    loadItems();
    setTimeout(() => checkSrtAvailability().catch(()=>{}), 1200);
  </script>
</body>
</html>
