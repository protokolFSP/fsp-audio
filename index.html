<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>FSP Audio ‚Äî G√ºncel</title>

  <meta name="description" content="FSP Audio ‚Äî G√ºncel kayƒ±t listesi ve oynatƒ±cƒ±." />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="FSP Audio ‚Äî G√ºncel" />
  <meta property="og:description" content="G√ºncel FSP kayƒ±tlarƒ±..." />
  <meta property="og:url" content="https://protokolfsp.github.io/fsp-audio/" />
  <meta property="og:image" content="https://protokolfsp.github.io/fsp-audio/og-home.png" />
  <meta property="og:image:width" content="1200" />
  <meta property="og:image:height" content="630" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:image" content="https://protokolfsp.github.io/fsp-audio/og-home.png" />

  <script async src="https://www.googletagmanager.com/gtag/js?id=G-TNRQ49C157"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    const __isDebug = new URLSearchParams(location.search).has('debug');
    gtag('config', 'G-TNRQ49C157', { debug_mode: __isDebug, send_page_view: true });
  </script>

  <link rel="stylesheet" href="https://cdn.plyr.io/3.7.8/plyr.css" />

  <style>
    :root{
      --border:#e9e9e9;
      --muted:#6b6b6b;
      --bg:#ffffff;
      --hover:#f7f7f7;

      --active:#cfe9ff;
      --activeGlow: 0 0 0 2px rgba(43,124,255,.34) inset, 0 12px 26px rgba(43,124,255,.14);

      --blue:#2b7cff;
      --blueGlow: 0 0 0 4px rgba(43,124,255,.24), 0 10px 22px rgba(43,124,255,.10);

      --green:#16a34a;
      --greenGlow: 0 0 0 4px rgba(22,163,74,.22), 0 10px 22px rgba(22,163,74,.10);

      --orange:#f59e0b;
    }

    html, body{
      height: 100%;
      overscroll-behavior-y: none;
      background: var(--bg);
    }

    body{
      margin: 0;
      overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color:#111;
      line-height: 1.10;
    }

    #scrollArea{
      height: 100%;
      overflow: auto;
      -webkit-overflow-scrolling: touch;
      overscroll-behavior-y: contain;
      padding: 18px;
      max-width: 980px;
      margin: 0 auto;
    }

    #appScale{
      transform-origin: top left;
      will-change: transform;
    }

    .pageTitle{
      font-size: 1.6rem;
      font-weight: 700;
      color: #0b5fff;
      background: #f1f5ff;
      padding: 12px 16px;
      border-radius: 14px;
      margin-bottom: 14px;
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
    }

    #sidebarOpenBtn{
      width: 44px;
      height: 40px;
      border-radius: 14px;
      border: 1px solid #d8d8d8;
      background: white;
      cursor: pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      user-select:none;
      flex: 0 0 auto;
    }
    #sidebarOpenBtn:hover{ background: var(--hover); }
    #sidebarOpenBtn svg{ width: 18px; height: 18px; }

    .navRow{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap: wrap;
      margin: 0 0 12px 0;
    }
    .navLink{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding: 8px 14px;
      border-radius: 999px;
      border: 1px solid #d8d8d8;
      background: white;
      color:#111;
      text-decoration:none;
      font-size: .95rem;
      line-height: 1;
      user-select:none;
      transition: background .15s ease, box-shadow .15s ease, border-color .15s ease;
    }
    .navLink:hover{ background: var(--hover); }
    .navLink.on{
      border-color:var(--blue);
      background: rgba(43,124,255,.10);
      box-shadow: 0 0 0 3px rgba(43,124,255,.16) inset;
    }

    .topbar{
      display:flex;
      gap:12px;
      align-items:center;
      margin-bottom: 8px;
      flex-wrap: wrap;
    }

    /* Sticky bar (CSS sticky where it works, JS docks it where it doesn't) */
    #stickyBar{
      position: sticky;
      top: 0;
      z-index: 1200;
      background: var(--bg);
      padding: 10px 0;
      border-radius: 16px;
      box-shadow:
        0 1px 0 rgba(0,0,0,.06),
        0 10px 18px rgba(0,0,0,.05);
    }
    #stickyBar.docked{
      position: fixed;
      z-index: 1200;
      padding: 10px 0;
      border-radius: 16px;
      box-shadow:
        0 1px 0 rgba(0,0,0,.06),
        0 14px 28px rgba(0,0,0,.10);
    }
    #stickyBarPh{ height: 0; }

    #search{
      flex: 1 1 520px;
      min-width: 220px;
      height: 46px;
      padding: 0 14px;
      border: 1px solid #d8d8d8;
      border-radius: 16px;
      font-size: 1.05rem;
      outline: none;
    }

    #resetBtn{
      height: 46px;
      padding: 0 16px;
      border: 1px solid #d8d8d8;
      border-radius: 16px;
      background: white;
      cursor: pointer;
      font-size: 1rem;
      flex: 0 0 auto;
    }
    #resetBtn:hover{ background: var(--hover); }

    .zoomWrap{
      display:flex;
      align-items:center;
      gap: 24px;
      margin-left: 14px;
      padding: 6px;
      border: 1px solid #d8d8d8;
      border-radius: 14px;
      background: white;
      user-select:none;
      flex: 0 0 auto;
    }
    .zoomBtn{
      height: 36px;
      width: 48px;
      border-radius: 12px;
      border: 1px solid #d8d8d8;
      background: white;
      cursor: pointer;
      line-height: 1;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 0;
      -webkit-tap-highlight-color: transparent;
      transition: opacity .15s ease, box-shadow .15s ease, border-color .15s ease, background .15s ease, filter .15s ease;
    }
    .zoomBtn:hover{ background: var(--hover); }
    .zoomBtn:disabled{ opacity: .35; cursor: default; }

    .zoomBtn svg{
      width: 20px;
      height: 20px;
      stroke: currentColor;
      fill: none;
      stroke-width: 2;
      stroke-linecap: round;
      stroke-linejoin: round;
      opacity: .95;
    }

    .zoomBtn.zoomOut,
    .zoomBtn.zoomIn{
      opacity: .55;
      filter: saturate(1.2);
      color: #111;
    }

    .zoomBtn.enabled.zoomOut{
      opacity: 1;
      background: rgba(255, 149, 0, .18);
      border-color: rgba(255, 149, 0, .70);
      box-shadow: 0 0 0 3px rgba(255, 149, 0, .16) inset, 0 8px 18px rgba(255, 149, 0, .12);
      filter: saturate(1.7);
      color: #b45309;
    }
    .zoomBtn.enabled.zoomIn{
      opacity: 1;
      background: rgba(34, 197, 94, .18);
      border-color: rgba(34, 197, 94, .70);
      box-shadow: 0 0 0 3px rgba(34, 197, 94, .16) inset, 0 8px 18px rgba(34, 197, 94, .12);
      filter: saturate(1.7);
      color: #15803d;
    }

    #meta{
      color: var(--muted);
      font-size: .95rem;
      margin: 6px 0 12px 2px;
      line-height: 1.05;
    }

    /* 7 column layout:
       1) title
       2) duration
       3) play count
       4) fav
       5) download
       6) download count
       7) transcript (txt)
    */
    .headerRow, .itemRow{
      display: grid;
      grid-template-columns: minmax(0, 1fr) 8ch 54px 36px 36px 54px 36px;
      align-items: center;
      column-gap: 8px;
    }

    .headerRow{
      padding: 6px 8px;
      border-top: 1px solid var(--border);
      border-bottom: 1px solid var(--border);
      color: var(--muted);
      font-size: .92rem;
      line-height: 1.05;
    }

    .titleHead, .durHead{
      display:flex;
      align-items:center;
      gap:8px;
      user-select:none;
      width: 100%;
    }
    .titleHead{ justify-content:flex-start; }
    .durHead{ justify-content:flex-end; }

    .headIconCell{
      display:flex;
      align-items:center;
      justify-content:center;
      user-select:none;
    }

    .txtHead{
      font-size: .85rem;
      color: var(--muted);
      user-select:none;
      line-height: 1;
    }

    .sortBtn{
      width: 28px;
      height: 28px;
      border-radius: 999px;
      border: 1px solid #d8d8d8;
      background: white;
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      color:#111;
      flex: 0 0 auto;
      position: relative;
    }
    .sortBtn:hover{ background: var(--hover); }
    .sortBtn.on{
      border-color:var(--blue);
      box-shadow: 0 0 0 3px rgba(43,124,255,.12) inset;
    }

    .sortBtn svg{
      width: 20px;
      height: 20px;
      display: block;
      flex: 0 0 auto;
    }
    .sortBtn .mainIcon{
      width: 20px;
      height: 20px;
    }
    .sortBtn .dirIcon{
      position: absolute;
      right: 4px;
      bottom: 2px;
      width: 12px;
      height: 12px;
      opacity: .95;
    }

    .iconOrange{ fill: var(--orange); }
    .iconBlue{ fill: var(--blue); }

    #list{
      border-bottom: 1px solid var(--border);
    }

    .itemRow{
      padding: 4px 8px;
      border-bottom: 1px solid #ececec;
      cursor: pointer;
      background: #f7f7f7;
    }
    #list .itemRow:nth-child(even){
      background: #eeeeee;
    }
    .itemRow:hover{ background: var(--hover); }

    .itemRow.active{
      background: var(--active) !important;
      box-shadow: var(--activeGlow);
      position: relative;
    }
    .itemRow.active:hover{ background: var(--active) !important; }
    .itemRow.active::before{
      content:"";
      position:absolute;
      left:0;
      top:0;
      bottom:0;
      width:4px;
      background: var(--blue);
      border-radius: 4px;
    }

    .title{
      font-size: 1.02rem;
      font-weight: 500;
      line-height: 1.02;
      min-width: 0;
    }

    .dur{
      text-align:right;
      color: var(--muted);
      font-variant-numeric: tabular-nums;
      font-size: .95rem;
      user-select:none;
      white-space: nowrap;
      line-height: 1.00;
    }

    .countCell{
      text-align: right;
      color: #404040;
      font-variant-numeric: tabular-nums;
      font-size: .92rem;
      user-select:none;
      white-space: nowrap;
      line-height: 1.00;
      padding-right: 2px;
    }

    @media (max-width: 680px){
      #scrollArea{ padding: 14px; }
      .headerRow, .itemRow{ grid-template-columns: minmax(0, 1fr) 8ch 46px 34px 34px 46px 34px; }
      .title{
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      #search{ flex: 1 1 100%; }
      .zoomWrap{ margin-left: 0; }
    }

    .iconBtn{
      width: 30px;
      height: 30px;
      border-radius: 999px;
      border: 1px solid #d8d8d8;
      background: white;
      display:flex;
      align-items:center;
      justify-content:center;
      cursor: pointer;
      user-select:none;
      transition: box-shadow .15s ease, border-color .15s ease, background .15s ease, opacity .15s ease;
      justify-self: center;
      -webkit-tap-highlight-color: transparent;
    }
    .iconBtn:hover{ background: var(--hover); }
    .iconBtn:disabled{ opacity: .35; cursor: default; }
    .iconBtn:disabled:hover{ background: white; }

    .iconBtn.txtMissing{
      opacity: .22 !important;
      filter: grayscale(1);
      border-style: dashed;
    }

    .iconBtn.on{
      border-color: var(--blue);
      background: rgba(43,124,255,.10);
      box-shadow: var(--blueGlow);
    }
    .iconBtn svg{ width: 14px; height: 14px; opacity: .9; }

    .filterBtn{
      width: 30px;
      height: 30px;
      border-radius: 999px;
      border: 1px solid #d8d8d8;
      background: white;
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      color:#111;
    }
    .filterBtn:hover{ background: var(--hover); }
    .filterBtn.on{
      border-color:var(--blue);
      box-shadow: 0 0 0 3px rgba(43,124,255,.12) inset;
    }
    .filterBtn svg{ width:14px; height:14px; }

    #floatingPlayer{
      position: fixed;
      left: max(18px, env(safe-area-inset-left));
      bottom: max(18px, env(safe-area-inset-bottom));
      width: min(720px, calc(100vw - 36px));
      background: white;

      border: 1.5px solid #d6d6d6;
      border-right-color: #bdbdbd;
      border-bottom-color:#b3b3b3;
      border-radius: 18px;

      box-shadow:
        10px 34px 86px rgba(0,0,0,.20),
        4px 14px 30px rgba(0,0,0,.10),
        0px 2px 6px rgba(0,0,0,.06);

      overflow: hidden;
      z-index: 9999;

      -webkit-transform: translateZ(0);
      transform: translateZ(0);
      transform-origin: top left;
      will-change: transform;
      transition: opacity .18s ease;
      touch-action: none;
    }

    /* Typing mode: do not block pointer events */
    #floatingPlayer.hiddenWhileTyping{ opacity: .35; }

    #fpHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 10px 12px;
      background: #fbfbfb;

      cursor: grab;
      user-select:none;
      gap: 10px;
      touch-action: none;
      line-height: 1.05;

      border-bottom: none;
      position: relative;

      box-shadow:
        inset 0 1px 0 rgba(255,255,255,.85),
        inset 0 -1px 0 rgba(0,0,0,.04);
    }

    #fpHeader::after{
      content:"";
      position:absolute;
      left:0; right:0; bottom:0;
      height: 2px;
      background: linear-gradient(
        to bottom,
        rgba(0,0,0,.18),
        rgba(255,255,255,.80)
      );
    }

    #fpTitle{
      font-weight: 650;
      font-size: 1rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      flex: 1 1 auto;
      min-width: 0;
      line-height: 1.12;
    }

    #fpHeaderRight{
      display:flex;
      align-items:center;
      gap: 8px;
      flex: 0 0 auto;
    }

    .miniBtn{
      width: 36px;
      height: 36px;
      border-radius: 12px;
      border: 1px solid #d8d8d8;
      background: white;
      cursor: pointer;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .miniBtn:hover{ background: var(--hover); }
    .miniBtn svg{ width:16px; height:16px; }

    .speedWrap{
      display:flex;
      align-items:center;
      gap: 6px;
      padding: 4px;
      border: 1px solid #d8d8d8;
      border-radius: 14px;
      background: white;
      user-select:none;
    }
    .speedCtlBtn{
      width: 36px;
      height: 36px;
      border-radius: 12px;
      border: 1px solid #d8d8d8;
      background: white;
      cursor: pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: 18px;
      line-height: 1;
    }
    .speedCtlBtn:hover{ background: var(--hover); }

    .speedValue{
      min-width: 56px;
      height: 36px;
      border-radius: 12px;
      border: 1px solid #d8d8d8;
      background: white;
      display:flex;
      align-items:center;
      justify-content:center;
      font-variant-numeric: tabular-nums;
      font-weight: 650;
      padding: 0 10px;
      cursor: default;
    }
    .speedValue.on{
      border-color:var(--blue);
      box-shadow: 0 0 0 3px rgba(43,124,255,.12) inset;
    }

    #fpBody{
      padding: 10px 12px 12px 12px;
      box-shadow: inset 0 1px 0 rgba(0,0,0,.05);
    }

    #status{
      margin: 8px 2px 0 2px;
      color: var(--muted);
      font-size: .92rem;
      line-height: 1.05;
    }

    .plyr--audio .plyr__controls{
      border-radius: 12px;
      flex-wrap: wrap;
      row-gap: 8px;
    }
    .plyr--audio .plyr__controls .plyr__progress{
      flex: 1 1 100%;
      min-width: 0;
    }

    @media (max-width: 680px){
      #fpHeader{ flex-wrap: wrap; gap: 8px; }
      #fpTitle{
        flex: 1 1 100%;
        white-space: normal;
        overflow: visible;
        text-overflow: clip;
      }
      #fpHeaderRight{
        width: 100%;
        justify-content: flex-end;
      }
    }

    .diseaseName{
      color: #c2410c;
      font-weight: 650;
    }

    /* Sidebar */
    #sbOverlay{
      position: fixed;
      left: 0; top: 0;
      width: 100vw;
      height: 100vh;
      z-index: 10020;
      display:none;
      background: rgba(0,0,0,.18);
      -webkit-transform: translateZ(0);
      transform: translateZ(0);
      will-change: transform, width, height;
    }
    #sbOverlay.open{ display:block; }

    #sidebar{
      position: absolute;
      left: max(12px, env(safe-area-inset-left));
      top: max(12px, env(safe-area-inset-top));
      width: min(360px, calc(100vw - 24px));
      height: min(86vh, 720px);
      background: #fff;
      border: 1.5px solid #d6d6d6;
      border-right-color: #bdbdbd;
      border-bottom-color:#b3b3b3;
      border-radius: 18px;
      box-shadow:
        10px 34px 86px rgba(0,0,0,.20),
        4px 14px 30px rgba(0,0,0,.10),
        0px 2px 6px rgba(0,0,0,.06);
      overflow: hidden;
      display:flex;
      flex-direction: column;
    }

    #sbHeader{
      padding: 10px 12px;
      background: #fbfbfb;
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      border-bottom: 1px solid #ececec;
      line-height: 1.05;
    }
    #sbTitle{
      font-weight: 750;
      font-size: 1rem;
      flex: 1 1 auto;
      min-width: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    #sbCloseBtn{
      width: 40px;
      height: 36px;
      border-radius: 12px;
      border: 1px solid #d8d8d8;
      background: white;
      cursor: pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      user-select:none;
    }
    #sbCloseBtn:hover{ background: var(--hover); }

    #sbBody{
      padding: 12px;
      overflow:auto;
      -webkit-overflow-scrolling: touch;
      flex: 1 1 auto;
      background:#fff;
    }

    .sbSection{
      border: 1px solid #e2e2e2;
      border-radius: 16px;
      padding: 10px;
      margin-bottom: 10px;
      background: #fff;
      box-shadow: inset 0 1px 0 rgba(0,0,0,.03);
    }
    .sbSection h3{
      margin: 0 0 8px 0;
      font-size: .95rem;
      color:#111;
    }
    .sbRow{
      display:flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items:center;
    }
    .sbBtn{
      height: 36px;
      padding: 0 12px;
      border-radius: 12px;
      border: 1px solid #d8d8d8;
      background: white;
      cursor: pointer;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      font-weight: 650;
      font-size: .92rem;
      user-select:none;
      line-height: 1;
    }
    .sbBtn:hover{ background: var(--hover); }
    .sbBtn.on{
      border-color:var(--blue);
      background: rgba(43,124,255,.10);
      box-shadow: 0 0 0 3px rgba(43,124,255,.12) inset;
    }
    .sbHint{
      color: var(--muted);
      font-size: .9rem;
      line-height: 1.2;
      margin-top: 6px;
    }

    /* Transcript popup */
    #txOverlay{
      position: fixed;
      left: 0; top: 0;
      width: 100vw;
      height: 100vh;
      z-index: 10050;
      display: none;
      background: rgba(0,0,0,.06);
      -webkit-transform: translateZ(0);
      transform: translateZ(0);
      will-change: transform, width, height;
      touch-action: none;
    }
    #txOverlay.open{ display: block; }

    #txPanel{
      position: absolute;
      top: max(14px, env(safe-area-inset-top));
      right: max(14px, env(safe-area-inset-right));
      width: min(760px, calc(100vw - 28px));
      height: min(70vh, 680px);
      background: #fff;
      border: 1.5px solid #d6d6d6;
      border-right-color: #bdbdbd;
      border-bottom-color:#b3b3b3;
      border-radius: 18px;
      box-shadow:
        10px 34px 86px rgba(0,0,0,.20),
        4px 14px 30px rgba(0,0,0,.10),
        0px 2px 6px rgba(0,0,0,.06);
      overflow: hidden;
      display:flex;
      flex-direction: column;
      touch-action: none;
    }

    #txHeader{
      padding: 10px 12px;
      background: #fbfbfb;
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      border-bottom: 1px solid #ececec;
      line-height: 1.05;
    }

    #txTitle{
      font-weight: 650;
      font-size: .98rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      flex: 1 1 auto;
      min-width: 0;
    }

    #txBtns{
      display:flex;
      gap: 8px;
      flex: 0 0 auto;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .txBtn{
      height: 36px;
      padding: 0 12px;
      border-radius: 12px;
      border: 1px solid #d8d8d8;
      background: white;
      cursor: pointer;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap: 8px;
      font-weight: 650;
      font-size: .92rem;
      user-select:none;
      line-height: 1;
      white-space: nowrap;
    }
    .txBtn:hover{ background: var(--hover); }
    .txBtn:disabled{ opacity: .45; cursor: default; }
    .txBtn svg{ width: 16px; height: 16px; }

    #txBody{
      padding: 10px 12px 12px 12px;
      overflow: auto;
      -webkit-overflow-scrolling: touch;
      flex: 1 1 auto;
      background: #fff;
    }

    #txInfo{
      color: var(--muted);
      font-size: .92rem;
      margin: 0 0 8px 0;
      line-height: 1.05;
    }

    #txSearchRow{
      display: none;
      gap: 8px;
      align-items: center;
      margin: 0 0 10px 0;
      padding: 8px;
      border: 1px solid #e2e2e2;
      border-radius: 14px;
      background: #fff;
      box-shadow: inset 0 1px 0 rgba(0,0,0,.03);
      position: sticky;
      top: 0;
      z-index: 3;
    }
    #txSearchRow.on{ display: flex; }

    #txSearchInput{
      flex: 1 1 auto;
      min-width: 140px;
      height: 46px;
      padding: 0 14px;
      border: 1px solid #d8d8d8;
      border-radius: 14px;
      font-size: 1.05rem;
      outline: none;
    }

    .txNavBtn{
      width: 60px;
      height: 46px;
      border-radius: 14px;
      border: 1px solid #d8d8d8;
      background: white;
      cursor: pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      user-select:none;
      font-weight: 900;
      font-size: 32px;
      line-height: 1;
    }
    .txNavBtn:hover{ background: var(--hover); }
    .txNavBtn:disabled{ opacity: .45; cursor: default; }

    #txMatchCount{
      min-width: 98px;
      text-align: right;
      color: #404040;
      font-variant-numeric: tabular-nums;
      font-size: .92rem;
      user-select:none;
    }

    #txContent{
      white-space: pre-wrap;
      word-break: break-word;
      font-variant-numeric: tabular-nums;
      line-height: 1.35;
      font-size: .92rem;
      margin: 0;
    }

    .txMark{
      background: rgba(43,124,255,.22);
      border-radius: 6px;
      padding: 0 2px;
    }
    .txMark.active{
      background: rgba(245,158,11,.35);
      box-shadow: 0 0 0 2px rgba(245,158,11,.20);
    }

    @media (max-width: 680px){
      #txHeader{ flex-wrap: wrap; gap: 8px; }
      #txTitle{
        flex: 1 1 100%;
        white-space: normal;
        overflow: visible;
        text-overflow: clip;
      }
      #txBtns{ width: 100%; justify-content: flex-end; }
      .txBtn{ height: 34px; padding: 0 10px; font-size: .9rem; }
    }

    #txResizeHandle{
      position: absolute;
      left: 0;
      bottom: 0;
      width: 38px;
      height: 38px;
      cursor: nwse-resize;
      display:flex;
      align-items:center;
      justify-content:center;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      touch-action: none;
      background: linear-gradient(135deg, rgba(43,124,255,.0), rgba(43,124,255,.12));
      border-top-right-radius: 16px;
    }
    #txResizeHandle svg{ width: 18px; height: 18px; opacity: .75; }
  </style>
</head>

<body>
  <div id="scrollArea">
    <div id="appScale">
      <div class="pageTitle">
        <span>FSP Audio ‚Äî G√ºncel</span>
        <button id="sidebarOpenBtn" type="button" aria-label="Men√º" title="Men√º">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
            <path d="M4 6h16"/><path d="M4 12h16"/><path d="M4 18h16"/>
          </svg>
        </button>
      </div>

      <nav class="navRow" aria-label="Sayfalar">
        <a class="navLink" href="https://protokolfsp.github.io/fsp-audio/">G√ºncel</a>
        <a class="navLink" href="https://protokolfsp.github.io/FSP2022-23/">2021‚Äì23</a>
        <a class="navLink" href="https://protokolfsp.github.io/All-in-One/">All-in-One</a>
        <a class="navLink" href="https://protokolfsp.github.io/Tlcfsp/">TLC</a>
        <a class="navLink" href="https://protokolfsp.github.io/MenschiB/">MenschiB</a>
        <a class="navLink" href="https://protokolfsp.github.io/FSP_DrYemliha/">DrYemliha Notlarƒ±</a>
        <a class="navLink" href="https://protokolfsp.github.io/FSP-Notlari/">FSP-NOTLARI</a>
      </nav>

      <div id="stickyBar">
        <div class="topbar">
          <input id="search" type="text" placeholder="Arama (√∂r. ACS, DM, PAVK)..." />
          <button id="resetBtn" type="button">Hepsi</button>

          <div class="zoomWrap" aria-label="G√∂r√ºn√ºm">
            <button id="zoomOutBtn" class="zoomBtn zoomOut" type="button" aria-label="K√º√ß√ºlt">
              <svg viewBox="0 0 24 24" aria-hidden="true">
                <circle cx="11" cy="11" r="6"></circle>
                <path d="M20 20l-3.5-3.5"></path>
                <path d="M8.5 11h5"></path>
              </svg>
            </button>

            <button id="zoomInBtn" class="zoomBtn zoomIn" type="button" aria-label="B√ºy√ºt">
              <svg viewBox="0 0 24 24" aria-hidden="true">
                <circle cx="11" cy="11" r="6"></circle>
                <path d="M20 20l-3.5-3.5"></path>
                <path d="M11 8.5v5"></path>
                <path d="M8.5 11h5"></path>
              </svg>
            </button>
          </div>
        </div>

        <div id="meta">G√∂r√ºn…ôn: 0 / Toplam: 0</div>

        <div class="headerRow">
          <div class="colTitle">
            <div class="titleHead">
              <span>Kayƒ±t</span>
              <button id="sortDateBtn" class="sortBtn" type="button" title="Tarihe g√∂re sƒ±rala (dosya sonu)">
                <svg id="sortDateIcon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true"></svg>
              </button>
            </div>
          </div>

          <div class="colDur" style="text-align:right;">
            <div class="durHead">
              <span>S√ºre</span>
              <button id="sortDurBtn" class="sortBtn" type="button" title="S√ºreye g√∂re sƒ±rala">
                <svg id="sortDurIcon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true"></svg>
              </button>
            </div>
          </div>

          <div class="headIconCell">
            <button id="sortPlayBtn" class="sortBtn" type="button" title="Dinlenme sayƒ±sƒ±na g√∂re sƒ±rala">
              <svg class="mainIcon" viewBox="0 0 24 24" aria-hidden="true">
                <path class="iconBlue" d="M3 10v4c0 .55.45 1 1 1h3l5 4V5L7 9H4c-.55 0-1 .45-1 1z"/>
                <path class="iconOrange" d="M16.5 8.5a1 1 0 0 1 1.4.1c1 1.2 1.6 2.7 1.6 4.4s-.6 3.2-1.6 4.4a1 1 0 1 1-1.5-1.3c.7-.9 1.1-2 1.1-3.1s-.4-2.2-1.1-3.1a1 1 0 0 1 .1-1.4z"/>
              </svg>
              <svg id="sortPlayIcon" class="dirIcon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true"></svg>
            </button>
          </div>

          <div class="headIconCell">
            <button id="filterFav" class="filterBtn" title="Favoriler filtrele" type="button" aria-pressed="false">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                <path d="M12 2l3.1 6.3 6.9 1-5 4.9 1.2 6.8L12 17.8 5.8 21l1.2-6.8-5-4.9 6.9-1L12 2z"/>
              </svg>
            </button>
          </div>

          <div class="headIconCell" aria-hidden="true"></div>

          <div class="headIconCell">
            <button id="sortDlCountBtn" class="sortBtn" type="button" title="ƒ∞ndirme sayƒ±sƒ±na g√∂re sƒ±rala">
              <svg class="mainIcon" viewBox="0 0 24 24" aria-hidden="true">
                <path class="iconBlue" d="M4 3h12l4 4v14a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2z"/>
                <path class="iconOrange" d="M7 3h8v6H7V3zm4 10.2a3.3 3.3 0 1 0 0 6.6 3.3 3.3 0 0 0 0-6.6z"/>
              </svg>
              <svg id="sortDlCountIcon" class="dirIcon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true"></svg>
            </button>
          </div>

          <div class="headIconCell">
            <span class="txtHead" title="Transkript">TXT</span>
          </div>
        </div>
      </div>

      <div id="stickyBarPh" aria-hidden="true"></div>

      <div id="list"></div>
      <div id="status"></div>
    </div>
  </div>

  <!-- Sidebar -->
  <div id="sbOverlay" aria-hidden="true">
    <div id="sidebar" role="dialog" aria-label="Men√º">
      <div id="sbHeader">
        <div id="sbTitle">Men√º</div>
        <button id="sbCloseBtn" type="button" aria-label="Kapat" title="Kapat">‚úï</button>
      </div>
      <div id="sbBody">
        <div class="sbSection">
          <h3>Hƒ±zlƒ±</h3>
          <div class="sbRow">
            <button id="sbRefreshBtn" class="sbBtn" type="button">Listeyi Yenile</button>
            <button id="sbZoomResetBtn" class="sbBtn" type="button">Zoom 100%</button>
          </div>
          <div class="sbHint">Listeyi yenile: Archive.org metadata tekrar okunur. (refresh parametresi yok)</div>
        </div>

        <div class="sbSection">
          <h3>Filtre / Sƒ±ralama</h3>
          <div class="sbRow">
            <button id="sbFavBtn" class="sbBtn" type="button">Favoriler</button>
          </div>
          <div class="sbRow" style="margin-top:8px;">
            <button id="sbSortDateBtn" class="sbBtn" type="button">Tarih</button>
            <button id="sbSortDurBtn" class="sbBtn" type="button">S√ºre</button>
            <button id="sbSortPlayBtn" class="sbBtn" type="button">Dinlenme</button>
            <button id="sbSortDlBtn" class="sbBtn" type="button">ƒ∞ndirme</button>
          </div>
          <div class="sbHint">Sƒ±ralama butonu: modu se√ßer. Aynƒ± moda tekrar basarsan y√∂n deƒüi≈üir.</div>
        </div>

        <div class="sbSection">
          <h3>Transkript</h3>
          <div class="sbRow">
            <button id="sbClearTxCacheBtn" class="sbBtn" type="button">TXT Cache Temizle</button>
          </div>
          <div class="sbHint">TXT‚Äôler sadece tƒ±klandƒ±ƒüƒ±nda y√ºklenir. Cache temizle: popup tekrar indirir.</div>
        </div>
      </div>
    </div>
  </div>

  <div id="floatingPlayer" role="region" aria-label="Oynatƒ±cƒ±">
    <div id="fpHeader" title="S√ºr√ºkle">
      <div id="fpTitle">Bir kayƒ±t se√ß...</div>
      <div id="fpHeaderRight">
        <div id="speedWrap" class="speedWrap" aria-label="Hƒ±z">
          <button id="slowBtn" class="speedCtlBtn" type="button" title="Yava≈ülat (üê¢)">üê¢</button>
          <div id="speedValue" class="speedValue on" title="Oynatma hƒ±zƒ±">1√ó</div>
          <button id="fastBtn" class="speedCtlBtn" type="button" title="Hƒ±zlandƒ±r (üêá)">üêá</button>
        </div>

        <button id="prevBtn" class="miniBtn" type="button" title="√ñnceki">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
            <path d="M19 20L9 12l10-8v16z"/><path d="M5 19V5"/>
          </svg>
        </button>
        <button id="nextBtn" class="miniBtn" type="button" title="Sonraki">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
            <path d="M5 4l10 8-10 8V4z"/><path d="M19 5v14"/>
          </svg>
        </button>
      </div>
    </div>
    <div id="fpBody">
      <audio id="player" class="js-player" controls preload="metadata"></audio>
    </div>
  </div>

  <!-- Transcript popup -->
  <div id="txOverlay" aria-hidden="true">
    <div id="txPanel" role="dialog" aria-label="Transkript">
      <div id="txHeader">
        <div id="txTitle">Transkript</div>
        <div id="txBtns">
          <button id="txCopyBtn" class="txBtn" type="button" title="Kopieren">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
              <path d="M9 9h10v10H9z"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
            </svg>
            Kopieren
          </button>
          <button id="txDownloadBtn" class="txBtn" type="button" title="Download">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
              <path d="M12 3v12"/><path d="M7 10l5 5 5-5"/><path d="M5 21h14"/>
            </svg>
            Download
          </button>
          <button id="txSearchBtn" class="txBtn" type="button" title="Suchen">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
              <circle cx="11" cy="11" r="6"></circle>
              <path d="M20 20l-3.5-3.5"></path>
            </svg>
            Suchen
          </button>
          <button id="txCloseBtn" class="txBtn" type="button" title="Schlie√üen">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
              <path d="M18 6L6 18"/><path d="M6 6l12 12"/>
            </svg>
            Schlie√üen
          </button>
        </div>
      </div>

      <div id="txBody">
        <div id="txInfo">‚Äî</div>

        <div id="txSearchRow" aria-label="Suchen">
          <input id="txSearchInput" type="text" placeholder="Suchen‚Ä¶" />
          <button id="txPrevMatchBtn" class="txNavBtn" type="button" title="Vorheriger Treffer">‚Äπ</button>
          <button id="txNextMatchBtn" class="txNavBtn" type="button" title="N√§chster Treffer">‚Ä∫</button>
          <div id="txMatchCount" title="Treffer">0/0</div>
        </div>

        <pre id="txContent"></pre>
      </div>

      <div id="txResizeHandle" title="Resize" aria-hidden="true">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
          <path d="M7 17l10-10"/><path d="M11 17h6v-6"/>
        </svg>
      </div>
    </div>
  </div>

  <script src="https://cdn.plyr.io/3.7.8/plyr.polyfilled.js"></script>

  <script>
    const IA_IDENTIFIER_1 = "vorhofflimmern-bei-bekannter-khk-dr-oemer-dr-remzi-09.05.25";
    const DL_PROXY = "https://fspdownload.protokolfsp.workers.dev/";
    const COUNTER_API = "https://fspdlcounter.protokolfsp.workers.dev";

    const FORCE_REFRESH = new URLSearchParams(location.search).has("refresh");

    const IS_SAFARI = (() => {
      const ua = navigator.userAgent || "";
      const isApple = /Mac|iPhone|iPad|iPod/i.test(ua);
      const hasSafari = /Safari/i.test(ua);
      const notChromeLike = !/Chrome|Chromium|CriOS|FxiOS|EdgiOS|Edg|OPR/i.test(ua);
      return isApple && hasSafari && notChromeLike;
    })();

    const scrollArea = document.getElementById("scrollArea");
    const listEl   = document.getElementById("list");
    const searchEl = document.getElementById("search");
    const metaEl   = document.getElementById("meta");
    const statusEl = document.getElementById("status");

    const stickyBar = document.getElementById("stickyBar");
    const stickyPh  = document.getElementById("stickyBarPh");

    const appScaleEl = document.getElementById("appScale");
    const zoomOutBtn = document.getElementById("zoomOutBtn");
    const zoomInBtn  = document.getElementById("zoomInBtn");

    const fp = document.getElementById("floatingPlayer");
    const fpHeader = document.getElementById("fpHeader");
    const fpTitle = document.getElementById("fpTitle");

    const playerEl = document.getElementById("player");
    const prevBtn = document.getElementById("prevBtn");
    const nextBtn = document.getElementById("nextBtn");

    const slowBtn = document.getElementById("slowBtn");
    const fastBtn = document.getElementById("fastBtn");
    const speedValueEl = document.getElementById("speedValue");

    const filterFavBtn  = document.getElementById("filterFav");
    const resetBtn      = document.getElementById("resetBtn");

    const sortDurBtn  = document.getElementById("sortDurBtn");
    const sortDurIcon = document.getElementById("sortDurIcon");
    const sortDateBtn  = document.getElementById("sortDateBtn");
    const sortDateIcon = document.getElementById("sortDateIcon");

    const sortPlayBtn  = document.getElementById("sortPlayBtn");
    const sortPlayIcon = document.getElementById("sortPlayIcon");
    const sortDlCountBtn  = document.getElementById("sortDlCountBtn");
    const sortDlCountIcon = document.getElementById("sortDlCountIcon");

    // Sidebar nodes
    const sidebarOpenBtn = document.getElementById("sidebarOpenBtn");
    const sbOverlay = document.getElementById("sbOverlay");
    const sbCloseBtn = document.getElementById("sbCloseBtn");
    const sbRefreshBtn = document.getElementById("sbRefreshBtn");
    const sbZoomResetBtn = document.getElementById("sbZoomResetBtn");
    const sbFavBtn = document.getElementById("sbFavBtn");
    const sbSortDateBtn = document.getElementById("sbSortDateBtn");
    const sbSortDurBtn = document.getElementById("sbSortDurBtn");
    const sbSortPlayBtn = document.getElementById("sbSortPlayBtn");
    const sbSortDlBtn = document.getElementById("sbSortDlBtn");
    const sbClearTxCacheBtn = document.getElementById("sbClearTxCacheBtn");

    // Transcript popup nodes
    const txOverlay = document.getElementById("txOverlay");
    const txPanel = document.getElementById("txPanel");
    const txResizeHandle = document.getElementById("txResizeHandle");
    const txTitleEl = document.getElementById("txTitle");
    const txInfoEl = document.getElementById("txInfo");
    const txContentEl = document.getElementById("txContent");
    const txBodyEl = document.getElementById("txBody");

    const txCopyBtn = document.getElementById("txCopyBtn");
    const txDownloadBtn = document.getElementById("txDownloadBtn");
    const txSearchBtn = document.getElementById("txSearchBtn");
    const txCloseBtn = document.getElementById("txCloseBtn");

    const txSearchRow = document.getElementById("txSearchRow");
    const txSearchInput = document.getElementById("txSearchInput");
    const txPrevMatchBtn = document.getElementById("txPrevMatchBtn");
    const txNextMatchBtn = document.getElementById("txNextMatchBtn");
    const txMatchCountEl = document.getElementById("txMatchCount");

    const plyr = new Plyr(playerEl, {
      seekTime: 5,
      controls: ["rewind","play","fast-forward","progress","current-time","duration","mute","volume"]
    });

    function gaEvent(name, params = {}) {
      try {
        if (typeof gtag !== "function") return;
        gtag("event", name, { ...params, page_path: location.pathname });
      } catch {}
    }
    function trackAudioPlay(it) {
      gaEvent("audio_play", {
        audio_id: it.id,
        audio_title: it.title,
        file_name: (it.name || "").split("/").pop() || "",
        src: it.src || "S1"
      });
    }
    function trackAudioDownload(it, filename) {
      gaEvent("audio_download", {
        audio_id: it.id,
        audio_title: it.title,
        file_name: filename || (it.name || "").split("/").pop() || "",
        src: it.src || "S1"
      });
    }
    function trackTranscriptOpen(it){
      gaEvent("transcript_open", {
        audio_id: it.id,
        audio_title: it.title,
        file_name: (it.txtName || "").split("/").pop() || "",
        src: it.src || "S1"
      });
    }
    function trackTranscriptDownload(it, filename){
      gaEvent("transcript_download", {
        audio_id: it.id,
        audio_title: it.title,
        file_name: filename || (it.txtName || "").split("/").pop() || "",
        src: it.src || "S1"
      });
    }

    let globalPlayCounts = {};
    let globalDownloadCounts = {};

    function chunk(arr, size){
      const out = [];
      for (let i=0; i<arr.length; i+=size) out.push(arr.slice(i, i+size));
      return out;
    }

    async function fetchCounts(type, ids){
      if (!ids.length) return {};
      try{
        const res = await fetch(COUNTER_API + "/counts", {
          method: "POST",
          mode: "cors",
          cache: "no-store",
          headers: {
            "content-type": IS_SAFARI ? "text/plain;charset=utf-8" : "application/json"
          },
          body: JSON.stringify({ type, ids })
        });
        if (!res.ok) throw new Error("counts failed");
        const j = await res.json();
        return (j && j.counts) ? j.counts : {};
      }catch{
        return {};
      }
    }

    let refreshCountsTimer = null;
    function scheduleRefreshCounts(ms = 800){
      clearTimeout(refreshCountsTimer);
      refreshCountsTimer = setTimeout(() => refreshAllCounts().catch(()=>{}), ms);
    }

    async function refreshAllCounts(){
      if (!items.length) return;

      const ids = items.map(it => it.id);
      const parts = chunk(ids, 200);

      const playAll = {};
      const dlAll = {};

      for (const part of parts){
        const [p, d] = await Promise.all([
          fetchCounts("play", part),
          fetchCounts("download", part),
        ]);
        Object.assign(playAll, p);
        Object.assign(dlAll, d);
      }

      const playHas = Object.keys(playAll).length > 0;
      const dlHas   = Object.keys(dlAll).length > 0;

      if (!playHas && !dlHas) return;

      if (playHas) globalPlayCounts = playAll;
      if (dlHas)   globalDownloadCounts = dlAll;

      render();
    }

    function sendHit(type, it){
      try{
        const payload = {
          type,
          id: it?.id || "",
          title: it?.title || "",
          file_name: (it?.name || "").split("/").pop() || ""
        };

        const url = COUNTER_API + "/hit";
        const data = JSON.stringify(payload);

        if (IS_SAFARI && navigator.sendBeacon){
          const ok = navigator.sendBeacon(
            url,
            new Blob([data], { type: "text/plain;charset=utf-8" })
          );
          if (ok) return;
        }

        fetch(url, {
          method: "POST",
          mode: "cors",
          cache: "no-store",
          keepalive: true,
          headers: {
            "content-type": IS_SAFARI ? "text/plain;charset=utf-8" : "application/json"
          },
          body: data
        }).catch(() => {});
      }catch{}
    }

    function bumpLocalGlobalCount(type, id){
      if (!id) return;
      if (type === "play"){
        globalPlayCounts[id] = (Number(globalPlayCounts[id]) || 0) + 1;
      } else {
        globalDownloadCounts[id] = (Number(globalDownloadCounts[id]) || 0) + 1;
      }
    }

    let playGate = { id: null, armed: false, sent: false };
    function armPlayGate(it){
      playGate = { id: it?.id || null, armed: true, sent: false };
    }
    function trySendPlayOnPlaying(){
      if (!playGate.armed || playGate.sent || !playGate.id) return;
      if (!playerEl || playerEl.paused) return;

      playGate.sent = true;
      const it = items.find(x => x.id === playGate.id) || { id: playGate.id, title:"", name:"" };
      bumpLocalGlobalCount("play", it.id);
      sendHit("play", it);
      scheduleRefreshCounts(1200);
      render();
    }
    playerEl.addEventListener("playing", trySendPlayOnPlaying);

    playerEl.addEventListener("error", () => {
      const code = playerEl?.error?.code;
      statusEl.textContent = "Audio hata: " + (code || "bilinmiyor");
    });

    const LS = {
      favs:  "fsp1.favs.v1",
      pos:   "fsp1.fp.pos.v1",
      durs:  "fsp1.durs.v1",
      sortMode: "fsp1.sort.mode.v2",
      sortDirDur: "fsp1.sort.dur.dir.v1",
      sortDirDate: "fsp1.sort.date.dir.v1",
      sortDirPlay: "fsp1.sort.play.dir.v1",
      sortDirDl:   "fsp1.sort.dl.dir.v1",
      speed: "fsp1.speed.v1",
      zoom:  "fsp1.ui.zoom.v1",

      itemsCache:   "fsp1.items.cache.s1.v2",
      itemsCacheAt: "fsp1.items.cache.s1.at.v1",
      metaUpdated:  "fsp1.items.meta.updated.s1.v1",
      uiState:      "fsp1.ui.state.v1",

      txSize: "fsp1.tx.size.v1"
    };

    const loadMap = (k) => { try { return JSON.parse(localStorage.getItem(k) || "{}"); } catch { return {}; } };
    const saveMap = (k, v) => localStorage.setItem(k, JSON.stringify(v));
    const loadAny = (k) => { try { return JSON.parse(localStorage.getItem(k) || "null"); } catch { return null; } };
    const saveAny = (k, v) => localStorage.setItem(k, JSON.stringify(v));

    let favs  = loadMap(LS.favs);
    let durs  = loadMap(LS.durs);

    let filterFav  = false;

    let items = [];
    let activeId = null;
    let selectedId = null;

    const CACHE_TTL_MS = 30 * 24 * 60 * 60 * 1000; // 30 g√ºn
    let pendingScrollTop = null;

    function itemsFingerprint(list){
      if (!Array.isArray(list) || !list.length) return "";
      return list.map(x => String(x?.id || "")).sort().join("|");
    }

    function saveUiState(){
      try{
        saveAny(LS.uiState, {
          q: (searchEl.value || ""),
          filterFav: !!filterFav,
          activeId: (activeId || null),
          selectedId: (selectedId || null),
          scrollTop: Number(scrollArea.scrollTop) || 0
        });
      }catch{}
    }

    function restoreUiState(){
      const s = loadAny(LS.uiState);
      if (!s) return;
      if (typeof s.q === "string") searchEl.value = s.q;
      if (typeof s.filterFav === "boolean") filterFav = s.filterFav;
      if (typeof s.activeId === "string") activeId = s.activeId;
      if (typeof s.selectedId === "string") selectedId = s.selectedId;
      else if (typeof s.activeId === "string") selectedId = s.activeId;
      if (typeof s.scrollTop === "number") pendingScrollTop = s.scrollTop;
    }

    function restoreScrollIfNeeded(){
      if (pendingScrollTop == null) return;
      const v = pendingScrollTop;
      pendingScrollTop = null;
      requestAnimationFrame(() => { scrollArea.scrollTop = v; });
    }

    window.addEventListener("pagehide", saveUiState);
    document.addEventListener("visibilitychange", () => {
      if (document.visibilityState === "hidden") saveUiState();
    });

    let sortMode = localStorage.getItem(LS.sortMode) || "date";
    let durSortDir  = (localStorage.getItem(LS.sortDirDur) === "desc") ? "desc" : "asc";
    let dateSortDir = (localStorage.getItem(LS.sortDirDate) === "asc") ? "asc" : "desc";
    let playSortDir = (localStorage.getItem(LS.sortDirPlay) === "asc") ? "asc" : "desc";
    let dlSortDir   = (localStorage.getItem(LS.sortDirDl) === "asc") ? "asc" : "desc";

    if (!localStorage.getItem(LS.sortMode)) localStorage.setItem(LS.sortMode, sortMode);
    if (!localStorage.getItem(LS.sortDirDate)) localStorage.setItem(LS.sortDirDate, dateSortDir);
    if (!localStorage.getItem(LS.sortDirPlay)) localStorage.setItem(LS.sortDirPlay, playSortDir);
    if (!localStorage.getItem(LS.sortDirDl)) localStorage.setItem(LS.sortDirDl, dlSortDir);

    const SPEEDS = [0.5, 0.75, 0.9, 1, 1.25, 1.5, 1.75, 2.0, 2.25];
    let speedIndex = SPEEDS.indexOf(1);

    function fmtSpeed(v){
      const s = (Math.round(v * 100) / 100).toString();
      return s.replace(/\.0+$/,"") + "√ó";
    }

    function setSpeedUI(v){
      speedValueEl.textContent = fmtSpeed(v);
      speedValueEl.classList.add("on");
      slowBtn.disabled = (speedIndex <= 0);
      fastBtn.disabled = (speedIndex >= SPEEDS.length - 1);
      slowBtn.style.opacity = slowBtn.disabled ? 0.45 : 1;
      fastBtn.style.opacity = fastBtn.disabled ? 0.45 : 1;
    }

    function applySpeedByIndex(idx){
      speedIndex = Math.max(0, Math.min(SPEEDS.length - 1, idx));
      const v = SPEEDS[speedIndex];
      plyr.speed = v;
      localStorage.setItem(LS.speed, String(v));
      setSpeedUI(v);
    }

    function restoreSpeed(){
      const saved = Number(localStorage.getItem(LS.speed) || "1");
      if (Number.isFinite(saved)){
        const i = SPEEDS.findIndex(x => Math.abs(x - saved) < 0.001);
        applySpeedByIndex(i === -1 ? SPEEDS.indexOf(1) : i);
      } else {
        applySpeedByIndex(SPEEDS.indexOf(1));
      }
    }

    slowBtn.addEventListener("click", (e) => { e.stopPropagation(); applySpeedByIndex(speedIndex - 1); });
    fastBtn.addEventListener("click", (e) => { e.stopPropagation(); applySpeedByIndex(speedIndex + 1); });

    const ZOOMS = [0.85, 0.9, 0.95, 1, 1.05, 1.1, 1.15, 1.2];
    let zoomIndex = ZOOMS.indexOf(1);
    let uiScale = 1;
    let useTransformScale = false;

    function getViewportWH(){
      const vv = window.visualViewport;
      const vw = (vv && vv.width)  ? vv.width  : window.innerWidth;
      const vh = (vv && vv.height) ? vv.height : window.innerHeight;
      return { vw, vh };
    }

    function toLayoutPx(v){
      return useTransformScale ? (v / uiScale) : v;
    }

    function updateOverlayScale(){
      const { vw, vh } = getViewportWH();
      if (!useTransformScale){
        sbOverlay.style.transform = "";
        sbOverlay.style.width = "100vw";
        sbOverlay.style.height = "100vh";
        txOverlay.style.transform = "";
        txOverlay.style.width = "100vw";
        txOverlay.style.height = "100vh";
        return;
      }
      const vwL = toLayoutPx(vw);
      const vhL = toLayoutPx(vh);

      for (const el of [sbOverlay, txOverlay]){
        el.style.transformOrigin = "top left";
        el.style.transform = `scale(${uiScale})`;
        el.style.width = vwL + "px";
        el.style.height = vhL + "px";
      }
    }

    function setZoomUI(v){
      const pct = Math.round(v * 100) + "%";
      zoomOutBtn.disabled = (zoomIndex <= 0);
      zoomInBtn.disabled  = (zoomIndex >= ZOOMS.length - 1);

      zoomOutBtn.classList.toggle("enabled", !zoomOutBtn.disabled);
      zoomInBtn.classList.toggle("enabled", !zoomInBtn.disabled);

      zoomOutBtn.title = `K√º√ß√ºlt (${pct})`;
      zoomInBtn.title  = `B√ºy√ºt (${pct})`;
      zoomOutBtn.setAttribute("aria-label", `K√º√ß√ºlt (${pct})`);
      zoomInBtn.setAttribute("aria-label", `B√ºy√ºt (${pct})`);
    }

    function applyZoomByIndex(idx){
      zoomIndex = Math.max(0, Math.min(ZOOMS.length - 1, idx));
      const v = ZOOMS[zoomIndex];
      uiScale = v;

      useTransformScale = !(window.CSS && CSS.supports && CSS.supports("zoom", "1"));

      if (!useTransformScale){
        document.documentElement.style.zoom = String(v);
        appScaleEl.style.transform = "";
        fp.style.transform = "";
      } else {
        document.documentElement.style.zoom = "";
        appScaleEl.style.transform = `scale(${v})`;
        fp.style.transform = `scale(${v})`;
      }

      localStorage.setItem(LS.zoom, String(v));
      setZoomUI(v);
      setTimeout(() => {
        clampPlayerToViewport();
        updateSticky(true);
      }, 0);
      updateOverlayScale();
      clampTxSizeToViewport();
    }

    function restoreZoom(){
      const saved = Number(localStorage.getItem(LS.zoom) || "1");
      if (Number.isFinite(saved)){
        const i = ZOOMS.findIndex(x => Math.abs(x - saved) < 0.001);
        applyZoomByIndex(i === -1 ? ZOOMS.indexOf(1) : i);
      } else {
        applyZoomByIndex(ZOOMS.indexOf(1));
      }
    }

    function resetZoom100(){ applyZoomByIndex(ZOOMS.indexOf(1)); }

    function attachDoubleTapReset(el){
      el.addEventListener("dblclick", (e) => { e.preventDefault(); resetZoom100(); });
      let lastTap = 0;
      el.addEventListener("touchend", (e) => {
        const now = Date.now();
        if (now - lastTap < 320){
          e.preventDefault();
          resetZoom100();
          lastTap = 0;
          return;
        }
        lastTap = now;
      }, { passive: false });
    }

    zoomOutBtn.addEventListener("click", (e) => { e.stopPropagation(); applyZoomByIndex(zoomIndex - 1); });
    zoomInBtn.addEventListener("click", (e) => { e.stopPropagation(); applyZoomByIndex(zoomIndex + 1); });
    attachDoubleTapReset(zoomOutBtn);
    attachDoubleTapReset(zoomInBtn);

    function setTypingMode(on){ fp.classList.toggle("hiddenWhileTyping", !!on); }

    function setMomentumScroll(el, on){
      try { if (el) el.style.webkitOverflowScrolling = on ? "auto" : "touch"; } catch {}
    }

    // Background usable: blur input when user interacts outside sticky bar.
    function maybeBlurMainSearch(e){
      if (document.activeElement !== searchEl) return;
      const t = e.target;
      if (t && t.closest && t.closest("#stickyBar")) return;
      searchEl.blur();
    }
    document.addEventListener("pointerdown", maybeBlurMainSearch, true);
    scrollArea.addEventListener("touchstart", () => {
      if (document.activeElement === searchEl) searchEl.blur();
    }, { passive: true });

    searchEl.addEventListener("focus", () => { setTypingMode(true); setMomentumScroll(scrollArea, true); });
    searchEl.addEventListener("blur",  () => { setTypingMode(false); setMomentumScroll(scrollArea, false); });

    txSearchInput.addEventListener("focus", () => setMomentumScroll(txBodyEl, true));
    txSearchInput.addEventListener("blur",  () => setMomentumScroll(txBodyEl, false));

    function escHtml(s){
      return (s ?? "").toString()
        .replace(/&/g,"&amp;")
        .replace(/</g,"&lt;")
        .replace(/>/g,"&gt;")
        .replace(/"/g,"&quot;")
        .replace(/'/g,"&#39;");
    }

    function highlightDisease(title){
      const raw = (title ?? "").toString();
      const m = raw.match(/\b(dr|fr)\b\.?/i);
      if (!m || m.index == null) return escHtml(raw);

      const i = m.index;
      const leftRaw = raw.slice(0, i);
      const leftTrim = leftRaw.trimEnd();
      if (!leftTrim.trim()) return escHtml(raw);

      const trailing = leftRaw.slice(leftTrim.length);
      return `<span class="diseaseName">${escHtml(leftTrim)}</span>${escHtml(trailing)}${escHtml(raw.slice(i))}`;
    }

    function foldTR(s){
      s = (s || "").toString();
      s = s.toLocaleLowerCase("tr");
      s = s.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
      s = s.replace(/ƒ±/g, "i");
      s = s.replace(/\s+/g, " ").trim();
      return s;
    }

    function guessMime(url){
      try{
        const p = new URL(url).pathname.toLowerCase();
        if (p.endsWith(".mp3")) return "audio/mpeg";
        if (p.endsWith(".m4a")) return "audio/mp4";
      }catch{}
      return "audio/*";
    }

    function fmtDur(sec){
      if (!Number.isFinite(sec) || sec <= 0) return "‚Äî";
      sec = Math.round(sec);
      const h = Math.floor(sec / 3600);
      const m = Math.floor((sec % 3600) / 60);
      const s = sec % 60;
      const mm = String(m).padStart(2, "0");
      const ss = String(s).padStart(2, "0");
      if (h > 0) return `${h}:${mm}:${ss}`;
      return `${m}:${ss}`;
    }

    function decodeURIComponentSafe(s){
      try { return decodeURIComponent(s); } catch { return s; }
    }

    function parseEndDate(item){
      const raw0 = (item.name || item.file || item.title || "").toString();
      let s;
      try { s = decodeURIComponent(raw0.split("/").pop() || raw0); } catch { s = raw0; }

      s = s.replace(/\.(mp3|m4a|wav|aac|ogg|flac)$/i, "").trim();
      s = s.normalize("NFKC").replace(/\u00A0/g, " ").trim();
      s = s.trim().replace(/[)\]\s]+$/g, "").trim();

      const m = s.match(/(\d{1,2})[.\-_\u00B7](\d{1,2})[.\-_\u00B7](\d{2}|\d{4})\s*$/);
      if (!m) return null;

      const dd = Number(m[1]);
      const mm = Number(m[2]);
      let yy = Number(m[3]);
      if (yy < 100) yy = 2000 + yy;
      if (!(dd >= 1 && dd <= 31 && mm >= 1 && mm <= 12)) return null;

      const t = Date.UTC(yy, mm - 1, dd);
      if (!Number.isFinite(t)) return null;

      const d = new Date(t);
      if (d.getUTCFullYear() !== yy || (d.getUTCMonth() + 1) !== mm || d.getUTCDate() !== dd) return null;
      return t;
    }

    function setArrowIcon(svgEl, isAsc) {
      if (!svgEl) return;
      while (svgEl.firstChild) svgEl.removeChild(svgEl.firstChild);

      const ns = "http://www.w3.org/2000/svg";

      const mkPath = (d) => {
        const p = document.createElementNS(ns, "path");
        p.setAttribute("d", d);
        p.setAttribute("fill", "none");
        p.setAttribute("stroke", "currentColor");
        p.setAttribute("stroke-width", "2");
        p.setAttribute("stroke-linecap", "round");
        p.setAttribute("stroke-linejoin", "round");
        return p;
      };

      svgEl.setAttribute("viewBox", "0 0 24 24");
      svgEl.setAttribute("aria-hidden", "true");
      svgEl.setAttribute("focusable", "false");

      svgEl.appendChild(mkPath(isAsc ? "M12 19V5" : "M12 5v14"));
      svgEl.appendChild(mkPath(isAsc ? "M7 10l5-5 5 5" : "M7 14l5 5 5-5"));
    }

    function setSortIcons(){
      sortDurBtn.classList.remove("on");
      sortDateBtn.classList.remove("on");
      sortPlayBtn.classList.remove("on");
      sortDlCountBtn.classList.remove("on");

      setArrowIcon(sortDurIcon, durSortDir === "asc");
      setArrowIcon(sortDateIcon, dateSortDir === "asc");
      setArrowIcon(sortPlayIcon, playSortDir === "asc");
      setArrowIcon(sortDlCountIcon, dlSortDir === "asc");

      if (sortMode === "dur") sortDurBtn.classList.add("on");
      if (sortMode === "date") sortDateBtn.classList.add("on");
      if (sortMode === "play") sortPlayBtn.classList.add("on");
      if (sortMode === "download") sortDlCountBtn.classList.add("on");

      sbFavBtn.classList.toggle("on", !!filterFav);
      sbSortDateBtn.classList.toggle("on", sortMode === "date");
      sbSortDurBtn.classList.toggle("on", sortMode === "dur");
      sbSortPlayBtn.classList.toggle("on", sortMode === "play");
      sbSortDlBtn.classList.toggle("on", sortMode === "download");
    }

    sortDurBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      if (sortMode !== "dur") sortMode = "dur";
      else durSortDir = (durSortDir === "asc") ? "desc" : "asc";
      localStorage.setItem(LS.sortMode, sortMode);
      localStorage.setItem(LS.sortDirDur, durSortDir);
      setSortIcons();
      render();
    });

    sortDateBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      if (sortMode !== "date") sortMode = "date";
      else dateSortDir = (dateSortDir === "asc") ? "desc" : "asc";
      localStorage.setItem(LS.sortMode, sortMode);
      localStorage.setItem(LS.sortDirDate, dateSortDir);
      setSortIcons();
      render();
    });

    sortPlayBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      if (sortMode !== "play") sortMode = "play";
      else playSortDir = (playSortDir === "asc") ? "desc" : "asc";
      localStorage.setItem(LS.sortMode, sortMode);
      localStorage.setItem(LS.sortDirPlay, playSortDir);
      setSortIcons();
      render();
    });

    sortDlCountBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      if (sortMode !== "download") sortMode = "download";
      else dlSortDir = (dlSortDir === "asc") ? "desc" : "asc";
      localStorage.setItem(LS.sortMode, sortMode);
      localStorage.setItem(LS.sortDirDl, dlSortDir);
      setSortIcons();
      render();
    });

    // Sticky docking (fixes Safari/transform zoom + keeps visible)
    let stickyStartTop = null;
    let stickyDocked = false;
    let stickyHomeParent = null;

    function measureStickyStartTop(){
      if (!stickyBar) return;
      if (stickyDocked) return;
      const barRect = stickyBar.getBoundingClientRect();
      const scRect  = scrollArea.getBoundingClientRect();
      stickyStartTop = (barRect.top - scRect.top) + scrollArea.scrollTop;
    }

    function getScrollAreaPadding(){
      const cs = getComputedStyle(scrollArea);
      const pt = parseFloat(cs.paddingTop) || 0;
      const pl = parseFloat(cs.paddingLeft) || 0;
      const pr = parseFloat(cs.paddingRight) || 0;
      return { pt, pl, pr };
    }

    function dockStickyBar(){
      if (stickyDocked) return;
      stickyDocked = true;
      stickyHomeParent = stickyBar.parentNode;
      stickyPh.style.height = stickyBar.offsetHeight + "px";
      stickyBar.classList.add("docked");
      document.body.appendChild(stickyBar);
      positionDockedStickyBar();
    }

    function undockStickyBar(){
      if (!stickyDocked) return;
      stickyDocked = false;
      stickyBar.classList.remove("docked");
      stickyBar.style.position = "";
      stickyBar.style.left = "";
      stickyBar.style.top = "";
      stickyBar.style.width = "";
      stickyBar.style.transform = "";
      stickyBar.style.transformOrigin = "";
      stickyPh.style.height = "0px";
      stickyHomeParent.insertBefore(stickyBar, stickyPh);
      measureStickyStartTop();
    }

    function positionDockedStickyBar(){
      if (!stickyDocked) return;
      const rect = scrollArea.getBoundingClientRect();
      const pad = getScrollAreaPadding();
      const left = rect.left + pad.pl;
      const top  = rect.top + pad.pt;
      const width = Math.max(260, rect.width - pad.pl - pad.pr);

      stickyBar.style.position = "fixed";
      stickyBar.style.transformOrigin = "top left";

      if (useTransformScale){
        stickyBar.style.left = (left / uiScale) + "px";
        stickyBar.style.top  = (top  / uiScale) + "px";
        stickyBar.style.width = (width / uiScale) + "px";
        stickyBar.style.transform = `scale(${uiScale})`;
      } else {
        stickyBar.style.left = left + "px";
        stickyBar.style.top  = top + "px";
        stickyBar.style.width = width + "px";
        stickyBar.style.transform = "";
      }
    }

    function updateSticky(forceRecalc = false){
      if (!stickyBar) return;

      const needDock = (IS_SAFARI || useTransformScale);

      if (forceRecalc && !stickyDocked){
        requestAnimationFrame(() => measureStickyStartTop());
      }

      if (!needDock){
        // Use native sticky
        if (stickyDocked) undockStickyBar();
        return;
      }

      if (stickyStartTop == null || forceRecalc){
        if (stickyDocked) undockStickyBar();
        measureStickyStartTop();
      }

      const shouldDock = (scrollArea.scrollTop > (stickyStartTop || 0));
      if (shouldDock && !stickyDocked) dockStickyBar();
      if (!shouldDock && stickyDocked) undockStickyBar();
      if (stickyDocked) positionDockedStickyBar();
    }

    scrollArea.addEventListener("scroll", () => updateSticky(false), { passive: true });

    const durQueue = [];
    const durLoading = new Set();
    let durActive = 0;
    const DUR_CONCURRENCY = 2;
    let rerenderTimer = null;

    function scheduleRerender(){
      if (rerenderTimer) return;
      rerenderTimer = setTimeout(() => {
        rerenderTimer = null;
        render();
      }, 120);
    }

    function requestDuration(it){
      const id = it.id;
      if (durs[id] > 0) return;
      if (durLoading.has(id)) return;
      durLoading.add(id);
      durQueue.push(it);
      pumpDurationQueue();
    }

    function pumpDurationQueue(){
      while (durActive < DUR_CONCURRENCY && durQueue.length){
        const it = durQueue.shift();
        durActive++;
        loadDurationFor(it).catch(() => {}).finally(() => {
          durActive--;
          pumpDurationQueue();
        });
      }
    }

    function loadDurationFor(it){
      return new Promise((resolve, reject) => {
        const a = new Audio();
        a.preload = "metadata";
        a.src = it.url;

        let done = false;

        const cleanup = () => {
          a.removeEventListener("loadedmetadata", onMeta);
          a.removeEventListener("error", onErr);
          try { a.src = ""; } catch {}
        };

        const finish = (ok, err) => {
          if (done) return;
          done = true;
          cleanup();
          durLoading.delete(it.id);
          ok ? resolve() : reject(err || new Error("metadata error"));
        };

        const onMeta = () => {
          const dur = a.duration;
          if (Number.isFinite(dur) && dur > 0){
            durs[it.id] = dur;
            saveMap(LS.durs, durs);
            scheduleRerender();
          }
          finish(true);
        };

        const onErr = () => finish(false, new Error("metadata error"));

        a.addEventListener("loadedmetadata", onMeta, { once: true });
        a.addEventListener("error", onErr, { once: true });

        setTimeout(() => {
          if (!done) finish(false, new Error("timeout"));
        }, 12000);
      });
    }

    function makeProxyUrl(fileUrl, filename){
      const u = DL_PROXY + "?u=" + encodeURIComponent(fileUrl);
      return filename ? (u + "&f=" + encodeURIComponent(filename)) : u;
    }

    function clickDownload(href, filename){
      const a = document.createElement("a");
      a.href = href;
      a.rel = "noopener";
      a.target = "_blank";
      if (filename) a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
    }

    async function forceDownload(fileUrl, filename){
      const proxied = makeProxyUrl(fileUrl, filename);
      try{
        clickDownload(proxied, filename);
        return;
      }catch{}

      try{
        const res = await fetch(proxied, { mode: "cors", cache: "no-store" });
        if (!res.ok) throw new Error("fetch failed");
        const blob = await res.blob();
        const url = URL.createObjectURL(blob);
        clickDownload(url, filename);
        setTimeout(() => URL.revokeObjectURL(url), 60_000);
      }catch{
        window.location.href = fileUrl;
      }
    }

    function buildDownloadUrl(identifier, name){
      const parts = (name || "").split("/").map(p => encodeURIComponent(p));
      return `https://archive.org/download/${identifier}/${parts.join("/")}`;
    }

    function replaceExtToTxt(name){
      const s = (name || "").toString();
      return s.replace(/\.(m4a|mp3)$/i, ".txt");
    }

    async function loadItems(){
      const cached = loadAny(LS.itemsCache);
      const cachedAt = Number(localStorage.getItem(LS.itemsCacheAt) || "0");
      const cacheFresh =
        !FORCE_REFRESH &&
        Array.isArray(cached) &&
        cached.length > 0 &&
        Number.isFinite(cachedAt) &&
        (Date.now() - cachedAt) < CACHE_TTL_MS;

      if (cacheFresh){
        items = cached;
        statusEl.textContent = "";
        setSortIcons();
        render();
        restoreScrollIfNeeded();
        scheduleRefreshCounts(50);
      } else {
        statusEl.textContent = "Y√ºkleniyor...";
      }

      try{
        const metaUrl = `https://archive.org/metadata/${encodeURIComponent(IA_IDENTIFIER_1)}`;
        const res = await fetch(metaUrl, { cache: FORCE_REFRESH ? "no-store" : "no-cache" });
        if (!res.ok) throw new Error("IA metadata okunamadƒ±");
        const j = await res.json();

        const newUpdated = String(
          j?.item_lastupdated ||
          j?.item_last_update ||
          j?.updated ||
          j?.metadata?.updateddate ||
          j?.metadata?.publicdate ||
          ""
        );
        const oldUpdated = String(localStorage.getItem(LS.metaUpdated) || "");

        if (cacheFresh && newUpdated && oldUpdated && newUpdated === oldUpdated){
          localStorage.setItem(LS.itemsCacheAt, String(Date.now()));
          return;
        }

        const files = Array.isArray(j.files) ? j.files : [];
        const txtLookup = new Map();
        for (const f of files){
          const nm = (f?.name || "").toString();
          if (!nm) continue;
          if (nm.toLowerCase().endsWith(".txt")){
            txtLookup.set(nm.toLowerCase(), nm);
          }
        }

        const list = files
          .filter(f => {
            const name = (f.name || "").toLowerCase();
            if (!(name.endsWith(".m4a") || name.endsWith(".mp3"))) return false;
            if (!("source" in f)) return true;
            return (String(f.source).toLowerCase() === "original");
          })
          .map((f, idx) => {
            const name = f.name || "";
            const title = (f.title || "").trim() || decodeURIComponentSafe(name.split("/").pop() || name);
            const url = buildDownloadUrl(IA_IDENTIFIER_1, name);
            const localId = name || url || (title + "#" + idx);
            const id = "S1|" + localId;

            const txtCandidateLower = replaceExtToTxt(name).toLowerCase();
            const txtName = txtLookup.get(txtCandidateLower) || "";
            const txtUrl = txtName ? buildDownloadUrl(IA_IDENTIFIER_1, txtName) : "";

            return { id, title, name, url, src: "S1", txtName, txtUrl };
          });

        const newFp = itemsFingerprint(list);
        const oldFp = itemsFingerprint(items);
        const shouldUpdate = !cacheFresh || (newFp && newFp !== oldFp);

        if (shouldUpdate){
          items = list;
          localStorage.setItem(LS.itemsCacheAt, String(Date.now()));
          localStorage.setItem(LS.itemsCache, JSON.stringify(items));
          if (newUpdated) localStorage.setItem(LS.metaUpdated, newUpdated);

          statusEl.textContent = items.length ? "" : "Kayƒ±t bulunamadƒ±.";
          setSortIcons();
          render();
          restoreScrollIfNeeded();
          scheduleRefreshCounts(100);
        } else {
          localStorage.setItem(LS.itemsCacheAt, String(Date.now()));
          if (newUpdated) localStorage.setItem(LS.metaUpdated, newUpdated);
        }

        updateSticky(true);
      }catch(err){
        console.error(err);
        if (!cacheFresh) statusEl.textContent = "Liste y√ºklenemedi.";
      }
    }

    function getVisibleItems(){
      const q = foldTR((searchEl.value || "").trim());

      let arr = items.filter(it => {
        if (q && !foldTR(it.title).includes(q)) return false;
        if (filterFav && !favs[it.id]) return false;
        return true;
      });

      if (sortMode === "dur"){
        const dir = (durSortDir === "asc") ? 1 : -1;
        arr.sort((a,b) => {
          const ha = (durs[a.id] > 0);
          const hb = (durs[b.id] > 0);
          if (ha !== hb) return ha ? -1 : 1;
          if (ha && hb){
            const da = durs[a.id];
            const db = durs[b.id];
            if (da !== db) return (da - db) * dir;
          }
          return a.title.localeCompare(b.title, "tr");
        });
      } else if (sortMode === "date"){
        const dir = (dateSortDir === "asc") ? 1 : -1;
        arr.sort((a,b) => {
          const ta = parseEndDate(a);
          const tb = parseEndDate(b);
          const ha = (ta !== null);
          const hb = (tb !== null);
          if (ha !== hb) return ha ? -1 : 1;
          if (ha && hb && ta !== tb) return (ta - tb) * dir;
          return a.title.localeCompare(b.title, "tr");
        });
      } else if (sortMode === "play"){
        const dir = (playSortDir === "asc") ? 1 : -1;
        arr.sort((a,b) => {
          const ca = Number(globalPlayCounts[a.id]) || 0;
          const cb = Number(globalPlayCounts[b.id]) || 0;
          if (ca !== cb) return (ca - cb) * dir;
          return a.title.localeCompare(b.title, "tr");
        });
      } else if (sortMode === "download"){
        const dir = (dlSortDir === "asc") ? 1 : -1;
        arr.sort((a,b) => {
          const ca = Number(globalDownloadCounts[a.id]) || 0;
          const cb = Number(globalDownloadCounts[b.id]) || 0;
          if (ca !== cb) return (ca - cb) * dir;
          return a.title.localeCompare(b.title, "tr");
        });
      } else {
        arr.sort((a,b) => a.title.localeCompare(b.title, "tr"));
      }

      return arr;
    }

    function iconButton(kind, on, title){
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "iconBtn" + (on ? " on" : "");
      btn.title = title;
      btn.dataset.kind = kind;

      if (kind === "star"){
        btn.setAttribute("aria-pressed", String(!!on));
        btn.innerHTML = `
          <svg viewBox="0 0 24 24" fill="${on ? "currentColor" : "none"}" stroke="currentColor" stroke-width="2" aria-hidden="true">
            <path d="M12 2l3.1 6.3 6.9 1-5 4.9 1.2 6.8L12 17.8 5.8 21l1.2-6.8-5-4.9 6.9-1L12 2z"/>
          </svg>`;
      } else if (kind === "download"){
        btn.innerHTML = `
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
            <path d="M12 3v12"/>
            <path d="M7 10l5 5 5-5"/>
            <path d="M5 21h14"/>
          </svg>`;
      } else if (kind === "txt"){
        btn.innerHTML = `
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
            <path d="M4 4h16v16H4z"/>
            <path d="M7 9h10"/>
            <path d="M7 13h10"/>
            <path d="M7 17h6"/>
          </svg>`;
      }

      return btn;
    }

    function render(){
      const visible = getVisibleItems();
      metaEl.textContent = `G√∂r√ºn…ôn: ${visible.length} / Toplam: ${items.length}`;

      filterFavBtn.classList.toggle("on", filterFav);
      filterFavBtn.setAttribute("aria-pressed",  String(filterFav));

      setSortIcons();

      listEl.innerHTML = "";

      const toMeasure = (sortMode === "dur") ? items : visible;
      for (const it of toMeasure){
        if (!(durs[it.id] > 0)) requestDuration(it);
      }

      for (const it of visible){
        const row = document.createElement("div");
        row.className = "itemRow" + (it.id === selectedId ? " active" : "");

        const title = document.createElement("div");
        title.className = "title";
        title.innerHTML = highlightDisease(it.title);

        const dur = document.createElement("div");
        dur.className = "dur";
        dur.textContent = (durs[it.id] > 0) ? fmtDur(durs[it.id]) : "‚Ä¶";

        const playCount = document.createElement("div");
        playCount.className = "countCell";
        playCount.textContent = String(Number(globalPlayCounts[it.id]) || 0);

        const favBtn = iconButton("star", !!favs[it.id], "Favori");
        const dlBtn  = iconButton("download", false, "ƒ∞ndir");

        const dlCount = document.createElement("div");
        dlCount.className = "countCell";
        dlCount.textContent = String(Number(globalDownloadCounts[it.id]) || 0);

        const hasTxt = !!(it.txtUrl && it.txtName);
        const txBtn = iconButton("txt", false, hasTxt ? "TXT" : "TXT yok");
        txBtn.disabled = !hasTxt;
        if (!hasTxt) txBtn.classList.add("txtMissing");

        favBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          selectedId = it.id;
          favs[it.id] = !favs[it.id];
          saveMap(LS.favs, favs);
          render();
        });

        dlBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          selectedId = it.id;

          const filename =
            (it.name || it.file || "").split("/").pop() ||
            (it.title || "audio").replace(/[\\/:*?"<>|]+/g, "_") + ".m4a";

          forceDownload(it.url, filename);

          setTimeout(() => {
            bumpLocalGlobalCount("download", it.id);
            sendHit("download", it);
            scheduleRefreshCounts(1200);
            trackAudioDownload(it, filename);
            render();
          }, 0);
        });

        txBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          selectedId = it.id;
          render();
          openTranscriptFor(it).catch(() => {});
        });

        for (const b of [favBtn, dlBtn, txBtn]){
          b.addEventListener("pointerup", (e) => e.stopPropagation());
          b.addEventListener("pointerdown", (e) => e.stopPropagation());
        }

        row.appendChild(title);
        row.appendChild(dur);
        row.appendChild(playCount);
        row.appendChild(favBtn);
        row.appendChild(dlBtn);
        row.appendChild(dlCount);
        row.appendChild(txBtn);

        // Only click on title starts playback; other columns only select.
        row.addEventListener("click", (e) => {
          const inTitle = !!(e.target && e.target.closest && e.target.closest(".title"));
          if (!inTitle){
            selectedId = it.id;
            render();
            return;
          }
          playById(it.id);
        });

        listEl.appendChild(row);
      }

      updateSticky(false);
    }

    function playById(id){
      const visible = getVisibleItems();
      const idx = visible.findIndex(x => x.id === id);
      if (idx === -1) return;
      playAtVisibleIndex(idx);
    }

    function setMediaSource(url, mime){
      while (playerEl.firstChild) playerEl.removeChild(playerEl.firstChild);
      const s = document.createElement("source");
      s.src = url;
      if (mime) s.type = mime;
      playerEl.appendChild(s);
      playerEl.load();
    }

    function playAtVisibleIndex(idx){
      const visible = getVisibleItems();
      const it = visible[idx];
      if (!it) return;

      armPlayGate(it);
      trackAudioPlay(it);

      statusEl.textContent = "";
      activeId = it.id;
      selectedId = it.id;
      fpTitle.textContent = it.title;
      render();

      const url = it.url;
      const mime = guessMime(url);
      const currentSpeed = SPEEDS[speedIndex] || 1;

      try{
        plyr.speed = currentSpeed;
        setMediaSource(url, mime);
        const p = plyr.play();
        if (p && typeof p.catch === "function"){
          p.catch(() => {
            statusEl.textContent = "Oynatma engellendi. Player i√ßindeki ‚ñ∂Ô∏é tu≈üuna bas.";
          });
        }
        setTimeout(() => {
          if (playerEl && playerEl.paused) {
            statusEl.textContent = statusEl.textContent || "Oynatma ba≈ülamadƒ±. Player i√ßindeki ‚ñ∂Ô∏é tu≈üuna bas.";
          }
        }, 900);
      }catch{
        statusEl.textContent = "Player ba≈ülatƒ±lamadƒ±.";
      }
    }

    function playPrev(){
      const visible = getVisibleItems();
      if (!visible.length) return;
      let idx = visible.findIndex(x => x.id === activeId);
      if (idx === -1) idx = 0;
      idx = (idx - 1 + visible.length) % visible.length;
      playAtVisibleIndex(idx);
    }

    function playNext(){
      const visible = getVisibleItems();
      if (!visible.length) return;
      let idx = visible.findIndex(x => x.id === activeId);
      if (idx === -1) idx = 0;
      idx = (idx + 1) % visible.length;
      playAtVisibleIndex(idx);
    }

    prevBtn.addEventListener("click", playPrev);
    nextBtn.addEventListener("click", playNext);
    plyr.on("ended", () => { setTimeout(() => playNext(), 0); });

    function isTypingTarget(){
      const tag = (document.activeElement && document.activeElement.tagName || "").toLowerCase();
      return (tag === "input" || tag === "textarea");
    }

    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape"){
        if (txOverlay.classList.contains("open")){
          e.preventDefault();
          closeTranscript();
          return;
        }
        if (sbOverlay.classList.contains("open")){
          e.preventDefault();
          closeSidebar();
          return;
        }
      }

      if (isTypingTarget()) return;

      if (e.code === "Space"){
        e.preventDefault();
        plyr.togglePlay();
      } else if (e.code === "ArrowLeft"){
        e.preventDefault();
        playPrev();
      } else if (e.code === "ArrowRight"){
        e.preventDefault();
        playNext();
      }
    });

    filterFavBtn.addEventListener("click", () => { filterFav = !filterFav; render(); });

    resetBtn.addEventListener("click", () => {
      filterFav = false;
      searchEl.value = "";

      sortMode = "date";
      dateSortDir = "desc";
      localStorage.setItem(LS.sortMode, sortMode);
      localStorage.setItem(LS.sortDirDate, dateSortDir);

      setSortIcons();
      render();
    });

    const SEARCH_DEBOUNCE_MS = 900;

    let searchTimer = null;
    let lastSentTermNorm = "";

    function sendSearchEvent(termRawInput) {
      const termRaw = (termRawInput || "").trim();
      const termNorm = foldTR(termRaw);
      const visibleCount = getVisibleItems().length;

      if (termRaw.length === 0) {
        if (lastSentTermNorm !== "") {
          lastSentTermNorm = "";
          gaEvent("search", { search_term: "", results_count: visibleCount });
        }
        return;
      }

      if (termNorm.length < 2) return;
      if (termNorm === lastSentTermNorm) return;

      lastSentTermNorm = termNorm;

      const params = { search_term: termNorm, results_count: visibleCount };
      if (__isDebug) params.search_term_raw = termRaw;

      gaEvent("search", params);
    }

    function renderAndTrackSearch() {
      render();
      sendSearchEvent(searchEl.value);
    }

    searchEl.addEventListener("input", () => {
      clearTimeout(searchTimer);
      searchTimer = setTimeout(renderAndTrackSearch, SEARCH_DEBOUNCE_MS);
    });

    searchEl.addEventListener("keydown", (e) => {
      if (e.key !== "Enter") return;
      e.preventDefault();
      clearTimeout(searchTimer);
      renderAndTrackSearch();
    });

    function restorePlayerPos(){
      try{
        const s = JSON.parse(localStorage.getItem(LS.pos) || "null");
        if (!s) return;
        if (typeof s.x === "number" && typeof s.y === "number"){
          fp.style.left = s.x + "px";
          fp.style.top = s.y + "px";
          fp.style.bottom = "auto";
          fp.style.right = "auto";
        }
      }catch{}
    }

    function savePlayerPos(x,y){
      localStorage.setItem(LS.pos, JSON.stringify({x,y}));
    }

    function clampPlayerToViewport(){
      const { vw, vh } = getViewportWH();

      const vwL = toLayoutPx(vw);
      const vhL = toLayoutPx(vh);

      const wL = fp.offsetWidth;
      const hL = fp.offsetHeight;

      const minX = 8;
      const minY = 8;
      const maxX = Math.max(minX, vwL - wL - 8);
      const maxY = Math.max(minY, vhL - hL - 8);

      const left = parseFloat(fp.style.left);
      const top  = parseFloat(fp.style.top);
      if (!Number.isFinite(left) || !Number.isFinite(top)) return;

      const nx = Math.min(maxX, Math.max(minX, left));
      const ny = Math.min(maxY, Math.max(minY, top));

      fp.style.left = nx + "px";
      fp.style.top  = ny + "px";
      fp.style.right = "auto";
      fp.style.bottom = "auto";

      savePlayerPos(nx, ny);
    }

    const DRAG_IGNORE_SELECTOR =
      "button, a, input, textarea, select, option, " +
      ".speedWrap, .speedCtlBtn, .miniBtn, " +
      ".plyr__controls, .plyr__control, .plyr__progress, .plyr__seek, .plyr__volume, .plyr__time, .plyr__menu";

    function shouldStartDrag(target){
      return !(target && target.closest && target.closest(DRAG_IGNORE_SELECTOR));
    }

    let dragging = false;
    let startClientX = 0, startClientY = 0;
    let startLeft = 0, startTop = 0;
    let moved = false;
    let suppressClickUntil = 0;

    function getCurrentLeftTopLayout(){
      const left = parseFloat(fp.style.left);
      const top  = parseFloat(fp.style.top);
      if (Number.isFinite(left) && Number.isFinite(top)) return { left, top };

      const rect = fp.getBoundingClientRect();
      const l = useTransformScale ? (rect.left / uiScale) : rect.left;
      const t = useTransformScale ? (rect.top  / uiScale) : rect.top;
      return { left: l, top: t };
    }

    fpHeader.addEventListener("pointerdown", (e) => {
      if (!shouldStartDrag(e.target)) return;

      dragging = true;
      moved = false;

      fpHeader.setPointerCapture(e.pointerId);
      fpHeader.style.cursor = "grabbing";

      startClientX = e.clientX;
      startClientY = e.clientY;

      const cur = getCurrentLeftTopLayout();
      startLeft = cur.left;
      startTop  = cur.top;

      fp.style.left = startLeft + "px";
      fp.style.top  = startTop + "px";
      fp.style.bottom = "auto";
      fp.style.right  = "auto";
    });

    fpHeader.addEventListener("pointermove", (e) => {
      if (!dragging) return;

      const dxClient = e.clientX - startClientX;
      const dyClient = e.clientY - startClientY;

      const dx = useTransformScale ? (dxClient / uiScale) : dxClient;
      const dy = useTransformScale ? (dyClient / uiScale) : dyClient;

      if (!moved && (Math.abs(dxClient) + Math.abs(dyClient) > 6)) moved = true;

      const { vw, vh } = getViewportWH();
      const vwL = toLayoutPx(vw);
      const vhL = toLayoutPx(vh);

      const wL = fp.offsetWidth;
      const hL = fp.offsetHeight;

      const minX = 8;
      const minY = 8;
      const maxX = Math.max(minX, vwL - wL - 8);
      const maxY = Math.max(minY, vhL - hL - 8);

      const nx = Math.min(maxX, Math.max(minX, startLeft + dx));
      const ny = Math.min(maxY, Math.max(minY, startTop  + dy));

      fp.style.left = nx + "px";
      fp.style.top  = ny + "px";
      savePlayerPos(nx, ny);
    });

    function endDrag(pointerId){
      if (!dragging) return;
      dragging = false;
      fpHeader.style.cursor = "grab";

      try { fpHeader.releasePointerCapture(pointerId); } catch {}
      clampPlayerToViewport();

      if (moved){
        suppressClickUntil = Date.now() + 350;
        moved = false;
      }
    }

    fpHeader.addEventListener("pointerup", (e) => endDrag(e.pointerId));
    fpHeader.addEventListener("pointercancel", (e) => endDrag(e.pointerId));

    fpHeader.addEventListener("click", (e) => {
      if (Date.now() < suppressClickUntil){
        e.preventDefault();
        e.stopPropagation();
      }
    }, true);

    window.addEventListener("resize", () => {
      clampPlayerToViewport();
      updateOverlayScale();
      clampTxSizeToViewport();
      updateSticky(true);
    });
    window.addEventListener("orientationchange", () => setTimeout(() => {
      clampPlayerToViewport();
      updateOverlayScale();
      clampTxSizeToViewport();
      updateSticky(true);
    }, 150));
    if (window.visualViewport){
      window.visualViewport.addEventListener("resize", () => {
        clampPlayerToViewport();
        updateOverlayScale();
        clampTxSizeToViewport();
        updateSticky(true);
      });
    }

    (function disablePullToRefresh(){
      let startY = 0;
      scrollArea.addEventListener("touchstart", (e) => {
        if (!e.touches || !e.touches.length) return;
        startY = e.touches[0].clientY;
      }, { passive: true });

      scrollArea.addEventListener("touchmove", (e) => {
        if (!e.touches || !e.touches.length) return;
        const y = e.touches[0].clientY;

        if (scrollArea.scrollTop <= 0 && y > startY + 4){
          e.preventDefault();
        }
      }, { passive: false });
    })();

    (function setActiveNav(){
      const here = location.href.replace(/\/$/, "");
      document.querySelectorAll(".navRow .navLink").forEach(a => {
        a.classList.remove("on");
        const u = (a.getAttribute("href") || "").replace(/\/$/, "");
        if (!u) return;
        if (here === u || here.startsWith(u + "/")) a.classList.add("on");
      });
    })();

    // Sidebar behavior
    function openSidebar(){
      sbOverlay.classList.add("open");
      sbOverlay.setAttribute("aria-hidden", "false");
      updateOverlayScale();
      setSortIcons();
    }
    function closeSidebar(){
      sbOverlay.classList.remove("open");
      sbOverlay.setAttribute("aria-hidden", "true");
    }
    sidebarOpenBtn.addEventListener("click", (e) => { e.stopPropagation(); openSidebar(); });
    sbCloseBtn.addEventListener("click", (e) => { e.stopPropagation(); closeSidebar(); });
    sbOverlay.addEventListener("click", (e) => {
      if (e.target === sbOverlay) closeSidebar();
    });
    document.getElementById("sidebar").addEventListener("click", (e) => e.stopPropagation());

    sbRefreshBtn.addEventListener("click", async () => {
      const old = localStorage.getItem(LS.itemsCacheAt) || "0";
      localStorage.setItem(LS.itemsCacheAt, "0");
      try{
        await loadItems();
      }finally{
        if (items.length) statusEl.textContent = "";
        else statusEl.textContent = "Kayƒ±t bulunamadƒ±.";
        if (old) localStorage.setItem(LS.itemsCacheAt, String(Date.now()));
      }
    });

    sbZoomResetBtn.addEventListener("click", () => resetZoom100());

    sbFavBtn.addEventListener("click", () => { filterFav = !filterFav; setSortIcons(); render(); });

    function clickSort(kind){
      if (kind === "date"){
        if (sortMode !== "date") sortMode = "date";
        else dateSortDir = (dateSortDir === "asc") ? "desc" : "asc";
        localStorage.setItem(LS.sortMode, sortMode);
        localStorage.setItem(LS.sortDirDate, dateSortDir);
      } else if (kind === "dur"){
        if (sortMode !== "dur") sortMode = "dur";
        else durSortDir = (durSortDir === "asc") ? "desc" : "asc";
        localStorage.setItem(LS.sortMode, sortMode);
        localStorage.setItem(LS.sortDirDur, durSortDir);
      } else if (kind === "play"){
        if (sortMode !== "play") sortMode = "play";
        else playSortDir = (playSortDir === "asc") ? "desc" : "asc";
        localStorage.setItem(LS.sortMode, sortMode);
        localStorage.setItem(LS.sortDirPlay, playSortDir);
      } else if (kind === "download"){
        if (sortMode !== "download") sortMode = "download";
        else dlSortDir = (dlSortDir === "asc") ? "desc" : "asc";
        localStorage.setItem(LS.sortMode, sortMode);
        localStorage.setItem(LS.sortDirDl, dlSortDir);
      }
      setSortIcons();
      render();
    }

    sbSortDateBtn.addEventListener("click", () => clickSort("date"));
    sbSortDurBtn.addEventListener("click", () => clickSort("dur"));
    sbSortPlayBtn.addEventListener("click", () => clickSort("play"));
    sbSortDlBtn.addEventListener("click", () => clickSort("download"));

    // Transcript logic
    let txOpen = false;
    let txCurrent = null;
    let txPlainText = "";
    let txMatches = [];
    let txActiveMatch = -1;
    let txSearchTimer = null;

    const txCache = new Map(); // id -> { text, at }
    const TX_CACHE_TTL_MS = 24 * 60 * 60 * 1000;

    function clearTxSearchUI(){
      txMatches = [];
      txActiveMatch = -1;
      txMatchCountEl.textContent = "0/0";
      txPrevMatchBtn.disabled = true;
      txNextMatchBtn.disabled = true;
      txContentEl.textContent = txPlainText || "";
    }

    function clampTxSizeToViewport(){
      const saved = loadAny(LS.txSize);
      if (saved && typeof saved.w === "number" && typeof saved.h === "number"){
        txPanel.style.width = saved.w + "px";
        txPanel.style.height = saved.h + "px";
      }

      const { vw, vh } = getViewportWH();
      const vwL = toLayoutPx(vw);
      const vhL = toLayoutPx(vh);

      const margin = 28;
      const maxW = Math.max(280, vwL - margin);
      const maxH = Math.max(220, vhL - margin);

      const curW = txPanel.offsetWidth;
      const curH = txPanel.offsetHeight;

      const w = Math.min(maxW, Math.max(360, curW));
      const h = Math.min(maxH, Math.max(300, curH));

      txPanel.style.width = w + "px";
      txPanel.style.height = h + "px";

      saveAny(LS.txSize, { w, h });
    }

    function openTranscript(){
      txOpen = true;
      txOverlay.classList.add("open");
      txOverlay.setAttribute("aria-hidden", "false");
      updateOverlayScale();
      clampTxSizeToViewport();
    }

    function closeTranscript(){
      txOpen = false;
      txOverlay.classList.remove("open");
      txOverlay.setAttribute("aria-hidden", "true");
      txSearchRow.classList.remove("on");
    }

    txCloseBtn.addEventListener("click", () => closeTranscript());

    function escapeForRegex(s){
      return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }

    function buildHighlightedHtml(text, ranges, activeIdx){
      if (!ranges.length) return escHtml(text);
      const parts = [];
      let last = 0;
      for (let i=0; i<ranges.length; i++){
        const r = ranges[i];
        const a = Math.max(0, r[0]);
        const b = Math.max(a, r[1]);
        if (a > last) parts.push(escHtml(text.slice(last, a)));
        const cls = (i === activeIdx) ? "txMark active" : "txMark";
        parts.push(`<span class="${cls}" data-mi="${i}">${escHtml(text.slice(a, b))}</span>`);
        last = b;
      }
      if (last < text.length) parts.push(escHtml(text.slice(last)));
      return parts.join("");
    }

    function computeMatches(text, q){
      const out = [];
      if (!q) return out;
      const re = new RegExp(escapeForRegex(q), "gi");
      let m;
      while ((m = re.exec(text))){
        const a = m.index;
        const b = a + (m[0] || "").length;
        if (b > a) out.push([a, b]);
        if (out.length >= 2000) break;
        if (m[0].length === 0) re.lastIndex++;
      }
      return out;
    }

    function applyTxSearch(){
      const q = (txSearchInput.value || "").trim();
      if (!q){
        clearTxSearchUI();
        return;
      }
      txMatches = computeMatches(txPlainText, q);
      txActiveMatch = txMatches.length ? 0 : -1;

      txPrevMatchBtn.disabled = txMatches.length < 2;
      txNextMatchBtn.disabled = txMatches.length < 2;

      txMatchCountEl.textContent = txMatches.length ? `1/${txMatches.length}` : `0/0`;

      txContentEl.innerHTML = buildHighlightedHtml(txPlainText, txMatches, txActiveMatch);

      if (txMatches.length){
        setTimeout(() => scrollToActiveMatch(), 0);
      }
    }

    function scrollToActiveMatch(){
      const el = txContentEl.querySelector(".txMark.active");
      if (!el) return;
      try{
        el.scrollIntoView({ block: "center", inline: "nearest", behavior: "smooth" });
      }catch{
        el.scrollIntoView();
      }
    }

    function setActiveMatch(idx){
      if (!txMatches.length) return;
      txActiveMatch = ((idx % txMatches.length) + txMatches.length) % txMatches.length;
      txMatchCountEl.textContent = `${txActiveMatch + 1}/${txMatches.length}`;

      const old = txContentEl.querySelector(".txMark.active");
      if (old) old.classList.remove("active");
      const next = txContentEl.querySelector(`.txMark[data-mi="${txActiveMatch}"]`);
      if (next){
        next.classList.add("active");
        scrollToActiveMatch();
      }else{
        txContentEl.innerHTML = buildHighlightedHtml(txPlainText, txMatches, txActiveMatch);
        setTimeout(() => scrollToActiveMatch(), 0);
      }
    }

    txSearchBtn.addEventListener("click", () => {
      const on = txSearchRow.classList.toggle("on");
      if (on){
        txSearchInput.focus();
        txSearchInput.select();
      }
    });

    txSearchInput.addEventListener("input", () => {
      clearTimeout(txSearchTimer);
      txSearchTimer = setTimeout(applyTxSearch, 180);
    });

    txSearchInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter"){
        e.preventDefault();
        if (!txMatches.length){
          applyTxSearch();
          return;
        }
        if (e.shiftKey) setActiveMatch(txActiveMatch - 1);
        else setActiveMatch(txActiveMatch + 1);
      } else if (e.key === "Escape"){
        e.preventDefault();
        txSearchRow.classList.remove("on");
      }
    });

    txPrevMatchBtn.addEventListener("click", () => setActiveMatch(txActiveMatch - 1));
    txNextMatchBtn.addEventListener("click", () => setActiveMatch(txActiveMatch + 1));

    async function copyToClipboard(text){
      if (!text) return false;
      try{
        await navigator.clipboard.writeText(text);
        return true;
      }catch{}
      try{
        const ta = document.createElement("textarea");
        ta.value = text;
        ta.style.position = "fixed";
        ta.style.left = "-9999px";
        ta.style.top = "-9999px";
        document.body.appendChild(ta);
        ta.focus();
        ta.select();
        const ok = document.execCommand("copy");
        ta.remove();
        return !!ok;
      }catch{
        return false;
      }
    }

    txCopyBtn.addEventListener("click", async () => {
      const ok = await copyToClipboard(txPlainText);
      txInfoEl.textContent = ok ? "Kopiert." : "Kopieren fehlgeschlagen.";
      setTimeout(() => {
        if (txCurrent) updateTxInfo(txCurrent);
      }, 1200);
    });

    txDownloadBtn.addEventListener("click", () => {
      if (!txCurrent || !txCurrent.txtUrl) return;
      const filename = (txCurrent.txtName || "").split("/").pop() || "transkript.txt";
      forceDownload(txCurrent.txtUrl, filename);
      trackTranscriptDownload(txCurrent, filename);
    });

    function updateTxInfo(it){
      const file = (it?.txtName || "").split("/").pop() || "‚Äî";
      txInfoEl.textContent = file ? `TXT: ${file}` : "‚Äî";
    }

    async function fetchTranscriptText(it){
      const cached = txCache.get(it.id);
      if (cached && (Date.now() - cached.at) < TX_CACHE_TTL_MS) return cached.text;

      const res = await fetch(it.txtUrl, { cache: "no-cache" });
      if (!res.ok) throw new Error("txt fetch failed");
      const text = await res.text();
      txCache.set(it.id, { text, at: Date.now() });
      return text;
    }

    async function openTranscriptFor(it){
      if (!it || !it.txtUrl) return;
      txCurrent = it;
      openTranscript();
      trackTranscriptOpen(it);

      txTitleEl.textContent = it.title || "Transkript";
      updateTxInfo(it);

      txCopyBtn.disabled = true;
      txDownloadBtn.disabled = false;
      txContentEl.textContent = "Y√ºkleniyor‚Ä¶";
      txPlainText = "";
      clearTxSearchUI();

      try{
        const t = await fetchTranscriptText(it);
        txPlainText = t || "";
        txCopyBtn.disabled = !txPlainText;
        clearTxSearchUI();
      }catch{
        txContentEl.textContent = "TXT y√ºklenemedi.";
        txCopyBtn.disabled = true;
      }
    }

    sbClearTxCacheBtn.addEventListener("click", () => {
      txCache.clear();
      txInfoEl.textContent = "TXT Cache temizlendi.";
      setTimeout(() => {
        if (txCurrent) updateTxInfo(txCurrent);
      }, 1200);
    });

    // Transcript overlay should NOT close on background click.
    txOverlay.addEventListener("click", () => {});
    txPanel.addEventListener("click", (e) => e.stopPropagation());

    // Resizable transcript panel
    let txResizing = false;
    let txResizeStartX = 0, txResizeStartY = 0;
    let txResizeStartW = 0, txResizeStartH = 0;

    function saveTxSize(w, h){
      saveAny(LS.txSize, { w, h });
    }

    function clampTxSize(w, h){
      const { vw, vh } = getViewportWH();
      const vwL = toLayoutPx(vw);
      const vhL = toLayoutPx(vh);

      const margin = 28;
      const maxW = Math.max(280, vwL - margin);
      const maxH = Math.max(220, vhL - margin);

      const minW = 360;
      const minH = 300;

      const cw = Math.min(maxW, Math.max(minW, w));
      const ch = Math.min(maxH, Math.max(minH, h));
      return { w: cw, h: ch };
    }

    txResizeHandle.addEventListener("pointerdown", (e) => {
      if (!txOpen) return;
      txResizing = true;
      txResizeStartX = e.clientX;
      txResizeStartY = e.clientY;
      txResizeStartW = txPanel.offsetWidth;
      txResizeStartH = txPanel.offsetHeight;
      txResizeHandle.setPointerCapture(e.pointerId);
      e.preventDefault();
      e.stopPropagation();
    });

    txResizeHandle.addEventListener("pointermove", (e) => {
      if (!txResizing) return;

      const dxClient = e.clientX - txResizeStartX;
      const dyClient = e.clientY - txResizeStartY;

      const dx = useTransformScale ? (dxClient / uiScale) : dxClient;
      const dy = useTransformScale ? (dyClient / uiScale) : dyClient;

      const w = txResizeStartW - dx; // handle is bottom-left
      const h = txResizeStartH + dy;

      const cl = clampTxSize(w, h);
      txPanel.style.width = cl.w + "px";
      txPanel.style.height = cl.h + "px";
      saveTxSize(cl.w, cl.h);
    });

    function endTxResize(pointerId){
      if (!txResizing) return;
      txResizing = false;
      try{ txResizeHandle.releasePointerCapture(pointerId); }catch{}
      clampTxSizeToViewport();
    }

    txResizeHandle.addEventListener("pointerup", (e) => endTxResize(e.pointerId));
    txResizeHandle.addEventListener("pointercancel", (e) => endTxResize(e.pointerId));

    // Init
    setSortIcons();
    restoreUiState();
    restorePlayerPos();
    restoreSpeed();
    restoreZoom();
    updateOverlayScale();
    requestAnimationFrame(() => {
      measureStickyStartTop();
      updateSticky(true);
    });
    setTimeout(clampPlayerToViewport, 0);
    loadItems();
  </script>
</body>
</html>
